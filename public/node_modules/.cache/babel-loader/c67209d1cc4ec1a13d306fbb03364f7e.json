{"ast":null,"code":"\"use strict\";\n/*\n * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // package java.io;\n// import java.util.Arrays;\n\nvar Arrays_1 = require(\"./Arrays\");\n\nvar OutputStream_1 = require(\"./OutputStream\");\n\nvar Integer_1 = require(\"./Integer\");\n\nvar IllegalArgumentException_1 = require(\"../IllegalArgumentException\");\n\nvar OutOfMemoryError_1 = require(\"../OutOfMemoryError\");\n\nvar System_1 = require(\"./System\");\n\nvar IndexOutOfBoundsException_1 = require(\"../IndexOutOfBoundsException\");\n/**\n * This class implements an output stream in which the data is\n * written into a byte array. The buffer automatically grows as data\n * is written to it.\n * The data can be retrieved using <code>toByteArray()</code> and\n * <code>toString()</code>.\n * <p>\n * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in\n * this class can be called after the stream has been closed without\n * generating an <tt>IOException</tt>.\n *\n * @author  Arthur van Hoff\n * @since   JDK1.0\n */\n\n\nvar ByteArrayOutputStream =\n/** @class */\nfunction (_super) {\n  __extends(ByteArrayOutputStream, _super);\n  /**\n   * Creates a new byte array output stream. The buffer capacity is\n   * initially 32 bytes, though its size increases if necessary.\n   */\n  // public constructor() {\n  //     this(32);\n  // }\n\n  /**\n   * Creates a new byte array output stream, with a buffer capacity of\n   * the specified size, in bytes.\n   *\n   * @param   size   the initial size.\n   * @exception  IllegalArgumentException if size is negative.\n   */\n\n\n  function ByteArrayOutputStream(size) {\n    if (size === void 0) {\n      size = 32;\n    }\n\n    var _this = _super.call(this) || this;\n    /**\n     * The number of valid bytes in the buffer.\n     */\n\n\n    _this.count = 0;\n\n    if (size < 0) {\n      throw new IllegalArgumentException_1.default('Negative initial size: ' + size);\n    }\n\n    _this.buf = new Uint8Array(size);\n    return _this;\n  }\n  /**\n   * Increases the capacity if necessary to ensure that it can hold\n   * at least the number of elements specified by the minimum\n   * capacity argument.\n   *\n   * @param minCapacity the desired minimum capacity\n   * @throws OutOfMemoryError if {@code minCapacity < 0}.  This is\n   * interpreted as a request for the unsatisfiably large capacity\n   * {@code (long) Integer.MAX_VALUE + (minCapacity - Integer.MAX_VALUE)}.\n   */\n\n\n  ByteArrayOutputStream.prototype.ensureCapacity = function (minCapacity) {\n    // overflow-conscious code\n    if (minCapacity - this.buf.length > 0) this.grow(minCapacity);\n  };\n  /**\n   * Increases the capacity to ensure that it can hold at least the\n   * number of elements specified by the minimum capacity argument.\n   *\n   * @param minCapacity the desired minimum capacity\n   */\n\n\n  ByteArrayOutputStream.prototype.grow = function (minCapacity) {\n    // overflow-conscious code\n    var oldCapacity = this.buf.length;\n    var newCapacity = oldCapacity << 1;\n    if (newCapacity - minCapacity < 0) newCapacity = minCapacity;\n\n    if (newCapacity < 0) {\n      if (minCapacity < 0) // overflow\n        throw new OutOfMemoryError_1.default();\n      newCapacity = Integer_1.default.MAX_VALUE;\n    }\n\n    this.buf = Arrays_1.default.copyOfUint8Array(this.buf, newCapacity);\n  };\n  /**\n   * Writes the specified byte to this byte array output stream.\n   *\n   * @param   b   the byte to be written.\n   */\n\n\n  ByteArrayOutputStream.prototype.write = function (b) {\n    this.ensureCapacity(this.count + 1);\n    this.buf[this.count] =\n    /*(byte)*/\n    b;\n    this.count += 1;\n  };\n  /**\n   * Writes <code>len</code> bytes from the specified byte array\n   * starting at offset <code>off</code> to this byte array output stream.\n   *\n   * @param   b     the data.\n   * @param   off   the start offset in the data.\n   * @param   len   the number of bytes to write.\n   */\n\n\n  ByteArrayOutputStream.prototype.writeBytesOffset = function (b, off, len) {\n    if (off < 0 || off > b.length || len < 0 || off + len - b.length > 0) {\n      throw new IndexOutOfBoundsException_1.default();\n    }\n\n    this.ensureCapacity(this.count + len);\n    System_1.default.arraycopy(b, off, this.buf, this.count, len);\n    this.count += len;\n  };\n  /**\n   * Writes the complete contents of this byte array output stream to\n   * the specified output stream argument, as if by calling the output\n   * stream's write method using <code>out.write(buf, 0, count)</code>.\n   *\n   * @param      out   the output stream to which to write the data.\n   * @exception  IOException  if an I/O error occurs.\n   */\n\n\n  ByteArrayOutputStream.prototype.writeTo = function (out) {\n    out.writeBytesOffset(this.buf, 0, this.count);\n  };\n  /**\n   * Resets the <code>count</code> field of this byte array output\n   * stream to zero, so that all currently accumulated output in the\n   * output stream is discarded. The output stream can be used again,\n   * reusing the already allocated buffer space.\n   *\n   * @see     java.io.ByteArrayInputStream#count\n   */\n\n\n  ByteArrayOutputStream.prototype.reset = function () {\n    this.count = 0;\n  };\n  /**\n   * Creates a newly allocated byte array. Its size is the current\n   * size of this output stream and the valid contents of the buffer\n   * have been copied into it.\n   *\n   * @return  the current contents of this output stream, as a byte array.\n   * @see     java.io.ByteArrayOutputStream#size()\n   */\n\n\n  ByteArrayOutputStream.prototype.toByteArray = function () {\n    return Arrays_1.default.copyOfUint8Array(this.buf, this.count);\n  };\n  /**\n   * Returns the current size of the buffer.\n   *\n   * @return  the value of the <code>count</code> field, which is the number\n   *          of valid bytes in this output stream.\n   * @see     java.io.ByteArrayOutputStream#count\n   */\n\n\n  ByteArrayOutputStream.prototype.size = function () {\n    return this.count;\n  };\n\n  ByteArrayOutputStream.prototype.toString = function (param) {\n    if (!param) {\n      return this.toString_void();\n    }\n\n    if (typeof param === 'string') {\n      return this.toString_string(param);\n    }\n\n    return this.toString_number(param);\n  };\n  /**\n   * Converts the buffer's contents into a string decoding bytes using the\n   * platform's default character set. The length of the new <tt>String</tt>\n   * is a function of the character set, and hence may not be equal to the\n   * size of the buffer.\n   *\n   * <p> This method always replaces malformed-input and unmappable-character\n   * sequences with the default replacement string for the platform's\n   * default character set. The {@linkplain java.nio.charset.CharsetDecoder}\n   * class should be used when more control over the decoding process is\n   * required.\n   *\n   * @return String decoded from the buffer's contents.\n   * @since  JDK1.1\n   */\n\n\n  ByteArrayOutputStream.prototype.toString_void = function () {\n    return new String(this.buf\n    /*, 0, this.count*/\n    ).toString();\n  };\n  /**\n   * Converts the buffer's contents into a string by decoding the bytes using\n   * the specified {@link java.nio.charset.Charset charsetName}. The length of\n   * the new <tt>String</tt> is a function of the charset, and hence may not be\n   * equal to the length of the byte array.\n   *\n   * <p> This method always replaces malformed-input and unmappable-character\n   * sequences with this charset's default replacement string. The {@link\n   * java.nio.charset.CharsetDecoder} class should be used when more control\n   * over the decoding process is required.\n   *\n   * @param  charsetName  the name of a supported\n   *              {@linkplain java.nio.charset.Charset </code>charset<code>}\n   * @return String decoded from the buffer's contents.\n   * @exception  UnsupportedEncodingException\n   *             If the named charset is not supported\n   * @since   JDK1.1\n   */\n\n\n  ByteArrayOutputStream.prototype.toString_string = function (charsetName) {\n    return new String(this.buf\n    /*, 0, this.count, charsetName*/\n    ).toString();\n  };\n  /**\n   * Creates a newly allocated string. Its size is the current size of\n   * the output stream and the valid contents of the buffer have been\n   * copied into it. Each character <i>c</i> in the resulting string is\n   * constructed from the corresponding element <i>b</i> in the byte\n   * array such that:\n   * <blockquote><pre>\n   *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))\n   * </pre></blockquote>\n   *\n   * @deprecated This method does not properly convert bytes into characters.\n   * As of JDK&nbsp;1.1, the preferred way to do this is via the\n   * <code>toString(String enc)</code> method, which takes an encoding-name\n   * argument, or the <code>toString()</code> method, which uses the\n   * platform's default character encoding.\n   *\n   * @param      hibyte    the high byte of each resulting Unicode character.\n   * @return     the current contents of the output stream, as a string.\n   * @see        java.io.ByteArrayOutputStream#size()\n   * @see        java.io.ByteArrayOutputStream#toString(String)\n   * @see        java.io.ByteArrayOutputStream#toString()\n   */\n  // @Deprecated\n\n\n  ByteArrayOutputStream.prototype.toString_number = function (hibyte) {\n    return new String(this.buf\n    /*, hibyte, 0, this.count*/\n    ).toString();\n  };\n  /**\n   * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in\n   * this class can be called after the stream has been closed without\n   * generating an <tt>IOException</tt>.\n   * <p>\n   *\n   * @throws IOException\n   */\n\n\n  ByteArrayOutputStream.prototype.close = function () {};\n\n  return ByteArrayOutputStream;\n}(OutputStream_1.default);\n\nexports.default = ByteArrayOutputStream;","map":{"version":3,"sources":["../../../src/core/util/ByteArrayOutputStream.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// package java.io;\n// import java.util.Arrays;\nvar Arrays_1 = require(\"./Arrays\");\nvar OutputStream_1 = require(\"./OutputStream\");\nvar Integer_1 = require(\"./Integer\");\nvar IllegalArgumentException_1 = require(\"../IllegalArgumentException\");\nvar OutOfMemoryError_1 = require(\"../OutOfMemoryError\");\nvar System_1 = require(\"./System\");\nvar IndexOutOfBoundsException_1 = require(\"../IndexOutOfBoundsException\");\n/**\n * This class implements an output stream in which the data is\n * written into a byte array. The buffer automatically grows as data\n * is written to it.\n * The data can be retrieved using <code>toByteArray()</code> and\n * <code>toString()</code>.\n * <p>\n * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in\n * this class can be called after the stream has been closed without\n * generating an <tt>IOException</tt>.\n *\n * @author  Arthur van Hoff\n * @since   JDK1.0\n */\nvar ByteArrayOutputStream = /** @class */ (function (_super) {\n    __extends(ByteArrayOutputStream, _super);\n    /**\n     * Creates a new byte array output stream. The buffer capacity is\n     * initially 32 bytes, though its size increases if necessary.\n     */\n    // public constructor() {\n    //     this(32);\n    // }\n    /**\n     * Creates a new byte array output stream, with a buffer capacity of\n     * the specified size, in bytes.\n     *\n     * @param   size   the initial size.\n     * @exception  IllegalArgumentException if size is negative.\n     */\n    function ByteArrayOutputStream(size) {\n        if (size === void 0) { size = 32; }\n        var _this = _super.call(this) || this;\n        /**\n         * The number of valid bytes in the buffer.\n         */\n        _this.count = 0;\n        if (size < 0) {\n            throw new IllegalArgumentException_1.default('Negative initial size: '\n                + size);\n        }\n        _this.buf = new Uint8Array(size);\n        return _this;\n    }\n    /**\n     * Increases the capacity if necessary to ensure that it can hold\n     * at least the number of elements specified by the minimum\n     * capacity argument.\n     *\n     * @param minCapacity the desired minimum capacity\n     * @throws OutOfMemoryError if {@code minCapacity < 0}.  This is\n     * interpreted as a request for the unsatisfiably large capacity\n     * {@code (long) Integer.MAX_VALUE + (minCapacity - Integer.MAX_VALUE)}.\n     */\n    ByteArrayOutputStream.prototype.ensureCapacity = function (minCapacity) {\n        // overflow-conscious code\n        if (minCapacity - this.buf.length > 0)\n            this.grow(minCapacity);\n    };\n    /**\n     * Increases the capacity to ensure that it can hold at least the\n     * number of elements specified by the minimum capacity argument.\n     *\n     * @param minCapacity the desired minimum capacity\n     */\n    ByteArrayOutputStream.prototype.grow = function (minCapacity) {\n        // overflow-conscious code\n        var oldCapacity = this.buf.length;\n        var newCapacity = oldCapacity << 1;\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        if (newCapacity < 0) {\n            if (minCapacity < 0) // overflow\n                throw new OutOfMemoryError_1.default();\n            newCapacity = Integer_1.default.MAX_VALUE;\n        }\n        this.buf = Arrays_1.default.copyOfUint8Array(this.buf, newCapacity);\n    };\n    /**\n     * Writes the specified byte to this byte array output stream.\n     *\n     * @param   b   the byte to be written.\n     */\n    ByteArrayOutputStream.prototype.write = function (b) {\n        this.ensureCapacity(this.count + 1);\n        this.buf[this.count] = /*(byte)*/ b;\n        this.count += 1;\n    };\n    /**\n     * Writes <code>len</code> bytes from the specified byte array\n     * starting at offset <code>off</code> to this byte array output stream.\n     *\n     * @param   b     the data.\n     * @param   off   the start offset in the data.\n     * @param   len   the number of bytes to write.\n     */\n    ByteArrayOutputStream.prototype.writeBytesOffset = function (b, off, len) {\n        if ((off < 0) || (off > b.length) || (len < 0) ||\n            ((off + len) - b.length > 0)) {\n            throw new IndexOutOfBoundsException_1.default();\n        }\n        this.ensureCapacity(this.count + len);\n        System_1.default.arraycopy(b, off, this.buf, this.count, len);\n        this.count += len;\n    };\n    /**\n     * Writes the complete contents of this byte array output stream to\n     * the specified output stream argument, as if by calling the output\n     * stream's write method using <code>out.write(buf, 0, count)</code>.\n     *\n     * @param      out   the output stream to which to write the data.\n     * @exception  IOException  if an I/O error occurs.\n     */\n    ByteArrayOutputStream.prototype.writeTo = function (out) {\n        out.writeBytesOffset(this.buf, 0, this.count);\n    };\n    /**\n     * Resets the <code>count</code> field of this byte array output\n     * stream to zero, so that all currently accumulated output in the\n     * output stream is discarded. The output stream can be used again,\n     * reusing the already allocated buffer space.\n     *\n     * @see     java.io.ByteArrayInputStream#count\n     */\n    ByteArrayOutputStream.prototype.reset = function () {\n        this.count = 0;\n    };\n    /**\n     * Creates a newly allocated byte array. Its size is the current\n     * size of this output stream and the valid contents of the buffer\n     * have been copied into it.\n     *\n     * @return  the current contents of this output stream, as a byte array.\n     * @see     java.io.ByteArrayOutputStream#size()\n     */\n    ByteArrayOutputStream.prototype.toByteArray = function () {\n        return Arrays_1.default.copyOfUint8Array(this.buf, this.count);\n    };\n    /**\n     * Returns the current size of the buffer.\n     *\n     * @return  the value of the <code>count</code> field, which is the number\n     *          of valid bytes in this output stream.\n     * @see     java.io.ByteArrayOutputStream#count\n     */\n    ByteArrayOutputStream.prototype.size = function () {\n        return this.count;\n    };\n    ByteArrayOutputStream.prototype.toString = function (param) {\n        if (!param) {\n            return this.toString_void();\n        }\n        if (typeof param === 'string') {\n            return this.toString_string(param);\n        }\n        return this.toString_number(param);\n    };\n    /**\n     * Converts the buffer's contents into a string decoding bytes using the\n     * platform's default character set. The length of the new <tt>String</tt>\n     * is a function of the character set, and hence may not be equal to the\n     * size of the buffer.\n     *\n     * <p> This method always replaces malformed-input and unmappable-character\n     * sequences with the default replacement string for the platform's\n     * default character set. The {@linkplain java.nio.charset.CharsetDecoder}\n     * class should be used when more control over the decoding process is\n     * required.\n     *\n     * @return String decoded from the buffer's contents.\n     * @since  JDK1.1\n     */\n    ByteArrayOutputStream.prototype.toString_void = function () {\n        return new String(this.buf /*, 0, this.count*/).toString();\n    };\n    /**\n     * Converts the buffer's contents into a string by decoding the bytes using\n     * the specified {@link java.nio.charset.Charset charsetName}. The length of\n     * the new <tt>String</tt> is a function of the charset, and hence may not be\n     * equal to the length of the byte array.\n     *\n     * <p> This method always replaces malformed-input and unmappable-character\n     * sequences with this charset's default replacement string. The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  charsetName  the name of a supported\n     *              {@linkplain java.nio.charset.Charset </code>charset<code>}\n     * @return String decoded from the buffer's contents.\n     * @exception  UnsupportedEncodingException\n     *             If the named charset is not supported\n     * @since   JDK1.1\n     */\n    ByteArrayOutputStream.prototype.toString_string = function (charsetName) {\n        return new String(this.buf /*, 0, this.count, charsetName*/).toString();\n    };\n    /**\n     * Creates a newly allocated string. Its size is the current size of\n     * the output stream and the valid contents of the buffer have been\n     * copied into it. Each character <i>c</i> in the resulting string is\n     * constructed from the corresponding element <i>b</i> in the byte\n     * array such that:\n     * <blockquote><pre>\n     *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))\n     * </pre></blockquote>\n     *\n     * @deprecated This method does not properly convert bytes into characters.\n     * As of JDK&nbsp;1.1, the preferred way to do this is via the\n     * <code>toString(String enc)</code> method, which takes an encoding-name\n     * argument, or the <code>toString()</code> method, which uses the\n     * platform's default character encoding.\n     *\n     * @param      hibyte    the high byte of each resulting Unicode character.\n     * @return     the current contents of the output stream, as a string.\n     * @see        java.io.ByteArrayOutputStream#size()\n     * @see        java.io.ByteArrayOutputStream#toString(String)\n     * @see        java.io.ByteArrayOutputStream#toString()\n     */\n    // @Deprecated\n    ByteArrayOutputStream.prototype.toString_number = function (hibyte) {\n        return new String(this.buf /*, hibyte, 0, this.count*/).toString();\n    };\n    /**\n     * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an <tt>IOException</tt>.\n     * <p>\n     *\n     * @throws IOException\n     */\n    ByteArrayOutputStream.prototype.close = function () {\n    };\n    return ByteArrayOutputStream;\n}(OutputStream_1.default));\nexports.default = ByteArrayOutputStream;\n//# sourceMappingURL=ByteArrayOutputStream.js.map"]},"metadata":{},"sourceType":"script"}
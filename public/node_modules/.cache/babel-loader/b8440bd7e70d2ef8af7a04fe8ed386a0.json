{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BitMatrix_1 = require(\"../../common/BitMatrix\");\n\nvar Version_1 = require(\"./Version\");\n\nvar FormatException_1 = require(\"../../FormatException\");\n\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @author bbrown@google.com (Brian Brown)\n */\n\n\nvar BitMatrixParser =\n/** @class */\nfunction () {\n  /**\n   * @param bitMatrix {@link BitMatrix} to parse\n   * @throws FormatException if dimension is < 8 or > 144 or not 0 mod 2\n   */\n  function BitMatrixParser(bitMatrix) {\n    var dimension = bitMatrix.getHeight();\n\n    if (dimension < 8 || dimension > 144 || (dimension & 0x01) !== 0) {\n      throw new FormatException_1.default();\n    }\n\n    this.version = BitMatrixParser.readVersion(bitMatrix);\n    this.mappingBitMatrix = this.extractDataRegion(bitMatrix);\n    this.readMappingMatrix = new BitMatrix_1.default(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());\n  }\n\n  BitMatrixParser.prototype.getVersion = function () {\n    return this.version;\n  };\n  /**\n   * <p>Creates the version object based on the dimension of the original bit matrix from\n   * the datamatrix code.</p>\n   *\n   * <p>See ISO 16022:2006 Table 7 - ECC 200 symbol attributes</p>\n   *\n   * @param bitMatrix Original {@link BitMatrix} including alignment patterns\n   * @return {@link Version} encapsulating the Data Matrix Code's \"version\"\n   * @throws FormatException if the dimensions of the mapping matrix are not valid\n   * Data Matrix dimensions.\n   */\n\n\n  BitMatrixParser.readVersion = function (bitMatrix) {\n    var numRows = bitMatrix.getHeight();\n    var numColumns = bitMatrix.getWidth();\n    return Version_1.default.getVersionForDimensions(numRows, numColumns);\n  };\n  /**\n   * <p>Reads the bits in the {@link BitMatrix} representing the mapping matrix (No alignment patterns)\n   * in the correct order in order to reconstitute the codewords bytes contained within the\n   * Data Matrix Code.</p>\n   *\n   * @return bytes encoded within the Data Matrix Code\n   * @throws FormatException if the exact number of bytes expected is not read\n   */\n\n\n  BitMatrixParser.prototype.readCodewords = function () {\n    var result = new Int8Array(this.version.getTotalCodewords());\n    var resultOffset = 0;\n    var row = 4;\n    var column = 0;\n    var numRows = this.mappingBitMatrix.getHeight();\n    var numColumns = this.mappingBitMatrix.getWidth();\n    var corner1Read = false;\n    var corner2Read = false;\n    var corner3Read = false;\n    var corner4Read = false; // Read all of the codewords\n\n    do {\n      // Check the four corner cases\n      if (row === numRows && column === 0 && !corner1Read) {\n        result[resultOffset++] = this.readCorner1(numRows, numColumns) & 0xff;\n        row -= 2;\n        column += 2;\n        corner1Read = true;\n      } else if (row === numRows - 2 && column === 0 && (numColumns & 0x03) !== 0 && !corner2Read) {\n        result[resultOffset++] = this.readCorner2(numRows, numColumns) & 0xff;\n        row -= 2;\n        column += 2;\n        corner2Read = true;\n      } else if (row === numRows + 4 && column === 2 && (numColumns & 0x07) === 0 && !corner3Read) {\n        result[resultOffset++] = this.readCorner3(numRows, numColumns) & 0xff;\n        row -= 2;\n        column += 2;\n        corner3Read = true;\n      } else if (row === numRows - 2 && column === 0 && (numColumns & 0x07) === 4 && !corner4Read) {\n        result[resultOffset++] = this.readCorner4(numRows, numColumns) & 0xff;\n        row -= 2;\n        column += 2;\n        corner4Read = true;\n      } else {\n        // Sweep upward diagonally to the right\n        do {\n          if (row < numRows && column >= 0 && !this.readMappingMatrix.get(column, row)) {\n            result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\n          }\n\n          row -= 2;\n          column += 2;\n        } while (row >= 0 && column < numColumns);\n\n        row += 1;\n        column += 3; // Sweep downward diagonally to the left\n\n        do {\n          if (row >= 0 && column < numColumns && !this.readMappingMatrix.get(column, row)) {\n            result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\n          }\n\n          row += 2;\n          column -= 2;\n        } while (row < numRows && column >= 0);\n\n        row += 3;\n        column += 1;\n      }\n    } while (row < numRows || column < numColumns);\n\n    if (resultOffset !== this.version.getTotalCodewords()) {\n      throw new FormatException_1.default();\n    }\n\n    return result;\n  };\n  /**\n   * <p>Reads a bit of the mapping matrix accounting for boundary wrapping.</p>\n   *\n   * @param row Row to read in the mapping matrix\n   * @param column Column to read in the mapping matrix\n   * @param numRows Number of rows in the mapping matrix\n   * @param numColumns Number of columns in the mapping matrix\n   * @return value of the given bit in the mapping matrix\n   */\n\n\n  BitMatrixParser.prototype.readModule = function (row, column, numRows, numColumns) {\n    // Adjust the row and column indices based on boundary wrapping\n    if (row < 0) {\n      row += numRows;\n      column += 4 - (numRows + 4 & 0x07);\n    }\n\n    if (column < 0) {\n      column += numColumns;\n      row += 4 - (numColumns + 4 & 0x07);\n    }\n\n    this.readMappingMatrix.set(column, row);\n    return this.mappingBitMatrix.get(column, row);\n  };\n  /**\n   * <p>Reads the 8 bits of the standard Utah-shaped pattern.</p>\n   *\n   * <p>See ISO 16022:2006, 5.8.1 Figure 6</p>\n   *\n   * @param row Current row in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\n   * @param column Current column in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\n   * @param numRows Number of rows in the mapping matrix\n   * @param numColumns Number of columns in the mapping matrix\n   * @return byte from the utah shape\n   */\n\n\n  BitMatrixParser.prototype.readUtah = function (row, column, numRows, numColumns) {\n    var currentByte = 0;\n\n    if (this.readModule(row - 2, column - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(row - 2, column - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(row - 1, column - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(row - 1, column - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(row - 1, column, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(row, column - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(row, column - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(row, column, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    return currentByte;\n  };\n  /**\n   * <p>Reads the 8 bits of the special corner condition 1.</p>\n   *\n   * <p>See ISO 16022:2006, Figure F.3</p>\n   *\n   * @param numRows Number of rows in the mapping matrix\n   * @param numColumns Number of columns in the mapping matrix\n   * @return byte from the Corner condition 1\n   */\n\n\n  BitMatrixParser.prototype.readCorner1 = function (numRows, numColumns) {\n    var currentByte = 0;\n\n    if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(numRows - 1, 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(numRows - 1, 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    return currentByte;\n  };\n  /**\n   * <p>Reads the 8 bits of the special corner condition 2.</p>\n   *\n   * <p>See ISO 16022:2006, Figure F.4</p>\n   *\n   * @param numRows Number of rows in the mapping matrix\n   * @param numColumns Number of columns in the mapping matrix\n   * @return byte from the Corner condition 2\n   */\n\n\n  BitMatrixParser.prototype.readCorner2 = function (numRows, numColumns) {\n    var currentByte = 0;\n\n    if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 4, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    return currentByte;\n  };\n  /**\n   * <p>Reads the 8 bits of the special corner condition 3.</p>\n   *\n   * <p>See ISO 16022:2006, Figure F.5</p>\n   *\n   * @param numRows Number of rows in the mapping matrix\n   * @param numColumns Number of columns in the mapping matrix\n   * @return byte from the Corner condition 3\n   */\n\n\n  BitMatrixParser.prototype.readCorner3 = function (numRows, numColumns) {\n    var currentByte = 0;\n\n    if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(1, numColumns - 3, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(1, numColumns - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    return currentByte;\n  };\n  /**\n   * <p>Reads the 8 bits of the special corner condition 4.</p>\n   *\n   * <p>See ISO 16022:2006, Figure F.6</p>\n   *\n   * @param numRows Number of rows in the mapping matrix\n   * @param numColumns Number of columns in the mapping matrix\n   * @return byte from the Corner condition 4\n   */\n\n\n  BitMatrixParser.prototype.readCorner4 = function (numRows, numColumns) {\n    var currentByte = 0;\n\n    if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    currentByte <<= 1;\n\n    if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\n      currentByte |= 1;\n    }\n\n    return currentByte;\n  };\n  /**\n   * <p>Extracts the data region from a {@link BitMatrix} that contains\n   * alignment patterns.</p>\n   *\n   * @param bitMatrix Original {@link BitMatrix} with alignment patterns\n   * @return BitMatrix that has the alignment patterns removed\n   */\n\n\n  BitMatrixParser.prototype.extractDataRegion = function (bitMatrix) {\n    var symbolSizeRows = this.version.getSymbolSizeRows();\n    var symbolSizeColumns = this.version.getSymbolSizeColumns();\n\n    if (bitMatrix.getHeight() !== symbolSizeRows) {\n      throw new IllegalArgumentException_1.default('Dimension of bitMatrix must match the version size');\n    }\n\n    var dataRegionSizeRows = this.version.getDataRegionSizeRows();\n    var dataRegionSizeColumns = this.version.getDataRegionSizeColumns();\n    var numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;\n    var numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;\n    var sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;\n    var sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;\n    var bitMatrixWithoutAlignment = new BitMatrix_1.default(sizeDataRegionColumn, sizeDataRegionRow);\n\n    for (var dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {\n      var dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;\n\n      for (var dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {\n        var dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;\n\n        for (var i = 0; i < dataRegionSizeRows; ++i) {\n          var readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i;\n          var writeRowOffset = dataRegionRowOffset + i;\n\n          for (var j = 0; j < dataRegionSizeColumns; ++j) {\n            var readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j;\n\n            if (bitMatrix.get(readColumnOffset, readRowOffset)) {\n              var writeColumnOffset = dataRegionColumnOffset + j;\n              bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);\n            }\n          }\n        }\n      }\n    }\n\n    return bitMatrixWithoutAlignment;\n  };\n\n  return BitMatrixParser;\n}();\n\nexports.default = BitMatrixParser;","map":{"version":3,"sources":["../../../../src/core/datamatrix/decoder/BitMatrixParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BitMatrix_1 = require(\"../../common/BitMatrix\");\nvar Version_1 = require(\"./Version\");\nvar FormatException_1 = require(\"../../FormatException\");\nvar IllegalArgumentException_1 = require(\"../../IllegalArgumentException\");\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @author bbrown@google.com (Brian Brown)\n */\nvar BitMatrixParser = /** @class */ (function () {\n    /**\n     * @param bitMatrix {@link BitMatrix} to parse\n     * @throws FormatException if dimension is < 8 or > 144 or not 0 mod 2\n     */\n    function BitMatrixParser(bitMatrix) {\n        var dimension = bitMatrix.getHeight();\n        if (dimension < 8 || dimension > 144 || (dimension & 0x01) !== 0) {\n            throw new FormatException_1.default();\n        }\n        this.version = BitMatrixParser.readVersion(bitMatrix);\n        this.mappingBitMatrix = this.extractDataRegion(bitMatrix);\n        this.readMappingMatrix = new BitMatrix_1.default(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());\n    }\n    BitMatrixParser.prototype.getVersion = function () {\n        return this.version;\n    };\n    /**\n     * <p>Creates the version object based on the dimension of the original bit matrix from\n     * the datamatrix code.</p>\n     *\n     * <p>See ISO 16022:2006 Table 7 - ECC 200 symbol attributes</p>\n     *\n     * @param bitMatrix Original {@link BitMatrix} including alignment patterns\n     * @return {@link Version} encapsulating the Data Matrix Code's \"version\"\n     * @throws FormatException if the dimensions of the mapping matrix are not valid\n     * Data Matrix dimensions.\n     */\n    BitMatrixParser.readVersion = function (bitMatrix) {\n        var numRows = bitMatrix.getHeight();\n        var numColumns = bitMatrix.getWidth();\n        return Version_1.default.getVersionForDimensions(numRows, numColumns);\n    };\n    /**\n     * <p>Reads the bits in the {@link BitMatrix} representing the mapping matrix (No alignment patterns)\n     * in the correct order in order to reconstitute the codewords bytes contained within the\n     * Data Matrix Code.</p>\n     *\n     * @return bytes encoded within the Data Matrix Code\n     * @throws FormatException if the exact number of bytes expected is not read\n     */\n    BitMatrixParser.prototype.readCodewords = function () {\n        var result = new Int8Array(this.version.getTotalCodewords());\n        var resultOffset = 0;\n        var row = 4;\n        var column = 0;\n        var numRows = this.mappingBitMatrix.getHeight();\n        var numColumns = this.mappingBitMatrix.getWidth();\n        var corner1Read = false;\n        var corner2Read = false;\n        var corner3Read = false;\n        var corner4Read = false;\n        // Read all of the codewords\n        do {\n            // Check the four corner cases\n            if ((row === numRows) && (column === 0) && !corner1Read) {\n                result[resultOffset++] = this.readCorner1(numRows, numColumns) & 0xff;\n                row -= 2;\n                column += 2;\n                corner1Read = true;\n            }\n            else if ((row === numRows - 2) && (column === 0) && ((numColumns & 0x03) !== 0) && !corner2Read) {\n                result[resultOffset++] = this.readCorner2(numRows, numColumns) & 0xff;\n                row -= 2;\n                column += 2;\n                corner2Read = true;\n            }\n            else if ((row === numRows + 4) && (column === 2) && ((numColumns & 0x07) === 0) && !corner3Read) {\n                result[resultOffset++] = this.readCorner3(numRows, numColumns) & 0xff;\n                row -= 2;\n                column += 2;\n                corner3Read = true;\n            }\n            else if ((row === numRows - 2) && (column === 0) && ((numColumns & 0x07) === 4) && !corner4Read) {\n                result[resultOffset++] = this.readCorner4(numRows, numColumns) & 0xff;\n                row -= 2;\n                column += 2;\n                corner4Read = true;\n            }\n            else {\n                // Sweep upward diagonally to the right\n                do {\n                    if ((row < numRows) && (column >= 0) && !this.readMappingMatrix.get(column, row)) {\n                        result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\n                    }\n                    row -= 2;\n                    column += 2;\n                } while ((row >= 0) && (column < numColumns));\n                row += 1;\n                column += 3;\n                // Sweep downward diagonally to the left\n                do {\n                    if ((row >= 0) && (column < numColumns) && !this.readMappingMatrix.get(column, row)) {\n                        result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\n                    }\n                    row += 2;\n                    column -= 2;\n                } while ((row < numRows) && (column >= 0));\n                row += 3;\n                column += 1;\n            }\n        } while ((row < numRows) || (column < numColumns));\n        if (resultOffset !== this.version.getTotalCodewords()) {\n            throw new FormatException_1.default();\n        }\n        return result;\n    };\n    /**\n     * <p>Reads a bit of the mapping matrix accounting for boundary wrapping.</p>\n     *\n     * @param row Row to read in the mapping matrix\n     * @param column Column to read in the mapping matrix\n     * @param numRows Number of rows in the mapping matrix\n     * @param numColumns Number of columns in the mapping matrix\n     * @return value of the given bit in the mapping matrix\n     */\n    BitMatrixParser.prototype.readModule = function (row, column, numRows, numColumns) {\n        // Adjust the row and column indices based on boundary wrapping\n        if (row < 0) {\n            row += numRows;\n            column += 4 - ((numRows + 4) & 0x07);\n        }\n        if (column < 0) {\n            column += numColumns;\n            row += 4 - ((numColumns + 4) & 0x07);\n        }\n        this.readMappingMatrix.set(column, row);\n        return this.mappingBitMatrix.get(column, row);\n    };\n    /**\n     * <p>Reads the 8 bits of the standard Utah-shaped pattern.</p>\n     *\n     * <p>See ISO 16022:2006, 5.8.1 Figure 6</p>\n     *\n     * @param row Current row in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\n     * @param column Current column in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\n     * @param numRows Number of rows in the mapping matrix\n     * @param numColumns Number of columns in the mapping matrix\n     * @return byte from the utah shape\n     */\n    BitMatrixParser.prototype.readUtah = function (row, column, numRows, numColumns) {\n        var currentByte = 0;\n        if (this.readModule(row - 2, column - 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(row - 2, column - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(row - 1, column - 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(row - 1, column - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(row - 1, column, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(row, column - 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(row, column - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(row, column, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        return currentByte;\n    };\n    /**\n     * <p>Reads the 8 bits of the special corner condition 1.</p>\n     *\n     * <p>See ISO 16022:2006, Figure F.3</p>\n     *\n     * @param numRows Number of rows in the mapping matrix\n     * @param numColumns Number of columns in the mapping matrix\n     * @return byte from the Corner condition 1\n     */\n    BitMatrixParser.prototype.readCorner1 = function (numRows, numColumns) {\n        var currentByte = 0;\n        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(numRows - 1, 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(numRows - 1, 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        return currentByte;\n    };\n    /**\n     * <p>Reads the 8 bits of the special corner condition 2.</p>\n     *\n     * <p>See ISO 16022:2006, Figure F.4</p>\n     *\n     * @param numRows Number of rows in the mapping matrix\n     * @param numColumns Number of columns in the mapping matrix\n     * @return byte from the Corner condition 2\n     */\n    BitMatrixParser.prototype.readCorner2 = function (numRows, numColumns) {\n        var currentByte = 0;\n        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 4, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        return currentByte;\n    };\n    /**\n     * <p>Reads the 8 bits of the special corner condition 3.</p>\n     *\n     * <p>See ISO 16022:2006, Figure F.5</p>\n     *\n     * @param numRows Number of rows in the mapping matrix\n     * @param numColumns Number of columns in the mapping matrix\n     * @return byte from the Corner condition 3\n     */\n    BitMatrixParser.prototype.readCorner3 = function (numRows, numColumns) {\n        var currentByte = 0;\n        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(1, numColumns - 3, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(1, numColumns - 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        return currentByte;\n    };\n    /**\n     * <p>Reads the 8 bits of the special corner condition 4.</p>\n     *\n     * <p>See ISO 16022:2006, Figure F.6</p>\n     *\n     * @param numRows Number of rows in the mapping matrix\n     * @param numColumns Number of columns in the mapping matrix\n     * @return byte from the Corner condition 4\n     */\n    BitMatrixParser.prototype.readCorner4 = function (numRows, numColumns) {\n        var currentByte = 0;\n        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        currentByte <<= 1;\n        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\n            currentByte |= 1;\n        }\n        return currentByte;\n    };\n    /**\n     * <p>Extracts the data region from a {@link BitMatrix} that contains\n     * alignment patterns.</p>\n     *\n     * @param bitMatrix Original {@link BitMatrix} with alignment patterns\n     * @return BitMatrix that has the alignment patterns removed\n     */\n    BitMatrixParser.prototype.extractDataRegion = function (bitMatrix) {\n        var symbolSizeRows = this.version.getSymbolSizeRows();\n        var symbolSizeColumns = this.version.getSymbolSizeColumns();\n        if (bitMatrix.getHeight() !== symbolSizeRows) {\n            throw new IllegalArgumentException_1.default('Dimension of bitMatrix must match the version size');\n        }\n        var dataRegionSizeRows = this.version.getDataRegionSizeRows();\n        var dataRegionSizeColumns = this.version.getDataRegionSizeColumns();\n        var numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;\n        var numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;\n        var sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;\n        var sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;\n        var bitMatrixWithoutAlignment = new BitMatrix_1.default(sizeDataRegionColumn, sizeDataRegionRow);\n        for (var dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {\n            var dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;\n            for (var dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {\n                var dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;\n                for (var i = 0; i < dataRegionSizeRows; ++i) {\n                    var readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i;\n                    var writeRowOffset = dataRegionRowOffset + i;\n                    for (var j = 0; j < dataRegionSizeColumns; ++j) {\n                        var readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j;\n                        if (bitMatrix.get(readColumnOffset, readRowOffset)) {\n                            var writeColumnOffset = dataRegionColumnOffset + j;\n                            bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);\n                        }\n                    }\n                }\n            }\n        }\n        return bitMatrixWithoutAlignment;\n    };\n    return BitMatrixParser;\n}());\nexports.default = BitMatrixParser;\n//# sourceMappingURL=BitMatrixParser.js.map"]},"metadata":{},"sourceType":"script"}
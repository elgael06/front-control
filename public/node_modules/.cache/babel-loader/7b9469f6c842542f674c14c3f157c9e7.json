{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar IllegalArgumentException_1 = require(\"./IllegalArgumentException\");\n\nvar BinaryBitmap =\n/** @class */\nfunction () {\n  function BinaryBitmap(binarizer) {\n    this.binarizer = binarizer;\n\n    if (binarizer === null) {\n      throw new IllegalArgumentException_1.default('Binarizer must be non-null.');\n    }\n  }\n  /**\n   * @return The width of the bitmap.\n   */\n\n\n  BinaryBitmap.prototype.getWidth = function () {\n    return this.binarizer.getWidth();\n  };\n  /**\n   * @return The height of the bitmap.\n   */\n\n\n  BinaryBitmap.prototype.getHeight = function () {\n    return this.binarizer.getHeight();\n  };\n  /**\n   * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return\n   * cached data. Callers should assume this method is expensive and call it as seldom as possible.\n   * This method is intended for decoding 1D barcodes and may choose to apply sharpening.\n   *\n   * @param y The row to fetch, which must be in [0, bitmap height)\n   * @param row An optional preallocated array. If null or too small, it will be ignored.\n   *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.\n   * @return The array of bits for this row (true means black).\n   * @throws NotFoundException if row can't be binarized\n   */\n\n\n  BinaryBitmap.prototype.getBlackRow = function (y\n  /*int*/\n  , row) {\n    return this.binarizer.getBlackRow(y, row);\n  };\n  /**\n   * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive\n   * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or\n   * may not apply sharpening. Therefore, a row from this matrix may not be identical to one\n   * fetched using getBlackRow(), so don't mix and match between them.\n   *\n   * @return The 2D array of bits for the image (true means black).\n   * @throws NotFoundException if image can't be binarized to make a matrix\n   */\n\n\n  BinaryBitmap.prototype.getBlackMatrix = function () {\n    // The matrix is created on demand the first time it is requested, then cached. There are two\n    // reasons for this:\n    // 1. This work will never be done if the caller only installs 1D Reader objects, or if a\n    //    1D Reader finds a barcode before the 2D Readers run.\n    // 2. This work will only be done once even if the caller installs multiple 2D Readers.\n    if (this.matrix === null || this.matrix === undefined) {\n      this.matrix = this.binarizer.getBlackMatrix();\n    }\n\n    return this.matrix;\n  };\n  /**\n   * @return Whether this bitmap can be cropped.\n   */\n\n\n  BinaryBitmap.prototype.isCropSupported = function () {\n    return this.binarizer.getLuminanceSource().isCropSupported();\n  };\n  /**\n   * Returns a new object with cropped image data. Implementations may keep a reference to the\n   * original data rather than a copy. Only callable if isCropSupported() is true.\n   *\n   * @param left The left coordinate, which must be in [0,getWidth())\n   * @param top The top coordinate, which must be in [0,getHeight())\n   * @param width The width of the rectangle to crop.\n   * @param height The height of the rectangle to crop.\n   * @return A cropped version of this object.\n   */\n\n\n  BinaryBitmap.prototype.crop = function (left\n  /*int*/\n  , top\n  /*int*/\n  , width\n  /*int*/\n  , height\n  /*int*/\n  ) {\n    var newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);\n    return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n  };\n  /**\n   * @return Whether this bitmap supports counter-clockwise rotation.\n   */\n\n\n  BinaryBitmap.prototype.isRotateSupported = function () {\n    return this.binarizer.getLuminanceSource().isRotateSupported();\n  };\n  /**\n   * Returns a new object with rotated image data by 90 degrees counterclockwise.\n   * Only callable if {@link #isRotateSupported()} is true.\n   *\n   * @return A rotated version of this object.\n   */\n\n\n  BinaryBitmap.prototype.rotateCounterClockwise = function () {\n    var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();\n    return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n  };\n  /**\n   * Returns a new object with rotated image data by 45 degrees counterclockwise.\n   * Only callable if {@link #isRotateSupported()} is true.\n   *\n   * @return A rotated version of this object.\n   */\n\n\n  BinaryBitmap.prototype.rotateCounterClockwise45 = function () {\n    var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();\n    return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n  };\n  /*@Override*/\n\n\n  BinaryBitmap.prototype.toString = function () {\n    try {\n      return this.getBlackMatrix().toString();\n    } catch (e\n    /*: NotFoundException*/\n    ) {\n      return '';\n    }\n  };\n\n  return BinaryBitmap;\n}();\n\nexports.default = BinaryBitmap;","map":{"version":3,"sources":["../../src/core/BinaryBitmap.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2009 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar IllegalArgumentException_1 = require(\"./IllegalArgumentException\");\nvar BinaryBitmap = /** @class */ (function () {\n    function BinaryBitmap(binarizer) {\n        this.binarizer = binarizer;\n        if (binarizer === null) {\n            throw new IllegalArgumentException_1.default('Binarizer must be non-null.');\n        }\n    }\n    /**\n     * @return The width of the bitmap.\n     */\n    BinaryBitmap.prototype.getWidth = function () {\n        return this.binarizer.getWidth();\n    };\n    /**\n     * @return The height of the bitmap.\n     */\n    BinaryBitmap.prototype.getHeight = function () {\n        return this.binarizer.getHeight();\n    };\n    /**\n     * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return\n     * cached data. Callers should assume this method is expensive and call it as seldom as possible.\n     * This method is intended for decoding 1D barcodes and may choose to apply sharpening.\n     *\n     * @param y The row to fetch, which must be in [0, bitmap height)\n     * @param row An optional preallocated array. If null or too small, it will be ignored.\n     *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.\n     * @return The array of bits for this row (true means black).\n     * @throws NotFoundException if row can't be binarized\n     */\n    BinaryBitmap.prototype.getBlackRow = function (y /*int*/, row) {\n        return this.binarizer.getBlackRow(y, row);\n    };\n    /**\n     * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive\n     * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or\n     * may not apply sharpening. Therefore, a row from this matrix may not be identical to one\n     * fetched using getBlackRow(), so don't mix and match between them.\n     *\n     * @return The 2D array of bits for the image (true means black).\n     * @throws NotFoundException if image can't be binarized to make a matrix\n     */\n    BinaryBitmap.prototype.getBlackMatrix = function () {\n        // The matrix is created on demand the first time it is requested, then cached. There are two\n        // reasons for this:\n        // 1. This work will never be done if the caller only installs 1D Reader objects, or if a\n        //    1D Reader finds a barcode before the 2D Readers run.\n        // 2. This work will only be done once even if the caller installs multiple 2D Readers.\n        if (this.matrix === null || this.matrix === undefined) {\n            this.matrix = this.binarizer.getBlackMatrix();\n        }\n        return this.matrix;\n    };\n    /**\n     * @return Whether this bitmap can be cropped.\n     */\n    BinaryBitmap.prototype.isCropSupported = function () {\n        return this.binarizer.getLuminanceSource().isCropSupported();\n    };\n    /**\n     * Returns a new object with cropped image data. Implementations may keep a reference to the\n     * original data rather than a copy. Only callable if isCropSupported() is true.\n     *\n     * @param left The left coordinate, which must be in [0,getWidth())\n     * @param top The top coordinate, which must be in [0,getHeight())\n     * @param width The width of the rectangle to crop.\n     * @param height The height of the rectangle to crop.\n     * @return A cropped version of this object.\n     */\n    BinaryBitmap.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n        var newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);\n        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n    };\n    /**\n     * @return Whether this bitmap supports counter-clockwise rotation.\n     */\n    BinaryBitmap.prototype.isRotateSupported = function () {\n        return this.binarizer.getLuminanceSource().isRotateSupported();\n    };\n    /**\n     * Returns a new object with rotated image data by 90 degrees counterclockwise.\n     * Only callable if {@link #isRotateSupported()} is true.\n     *\n     * @return A rotated version of this object.\n     */\n    BinaryBitmap.prototype.rotateCounterClockwise = function () {\n        var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();\n        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n    };\n    /**\n     * Returns a new object with rotated image data by 45 degrees counterclockwise.\n     * Only callable if {@link #isRotateSupported()} is true.\n     *\n     * @return A rotated version of this object.\n     */\n    BinaryBitmap.prototype.rotateCounterClockwise45 = function () {\n        var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();\n        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n    };\n    /*@Override*/\n    BinaryBitmap.prototype.toString = function () {\n        try {\n            return this.getBlackMatrix().toString();\n        }\n        catch (e /*: NotFoundException*/) {\n            return '';\n        }\n    };\n    return BinaryBitmap;\n}());\nexports.default = BinaryBitmap;\n//# sourceMappingURL=BinaryBitmap.js.map"]},"metadata":{},"sourceType":"script"}
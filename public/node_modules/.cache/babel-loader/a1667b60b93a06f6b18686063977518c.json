{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar DecoderResult_1 = require(\"../../common/DecoderResult\");\n\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\n\nvar ReedSolomonDecoder_1 = require(\"../../common/reedsolomon/ReedSolomonDecoder\");\n\nvar IllegalStateException_1 = require(\"../../IllegalStateException\");\n\nvar FormatException_1 = require(\"../../FormatException\");\n\nvar __1 = require(\"../../..\");\n\nvar Integer_1 = require(\"../../util/Integer\"); // import java.util.Arrays;\n\n\nvar Table;\n\n(function (Table) {\n  Table[Table[\"UPPER\"] = 0] = \"UPPER\";\n  Table[Table[\"LOWER\"] = 1] = \"LOWER\";\n  Table[Table[\"MIXED\"] = 2] = \"MIXED\";\n  Table[Table[\"DIGIT\"] = 3] = \"DIGIT\";\n  Table[Table[\"PUNCT\"] = 4] = \"PUNCT\";\n  Table[Table[\"BINARY\"] = 5] = \"BINARY\";\n})(Table || (Table = {}));\n/**\n * <p>The main class which implements Aztec Code decoding -- as opposed to locating and extracting\n * the Aztec Code from an image.</p>\n *\n * @author David Olivier\n */\n\n\nvar Decoder =\n/** @class */\nfunction () {\n  function Decoder() {}\n\n  Decoder.prototype.decode = function (detectorResult) {\n    this.ddata = detectorResult;\n    var matrix = detectorResult.getBits();\n    var rawbits = this.extractBits(matrix);\n    var correctedBits = this.correctBits(rawbits);\n    var rawBytes = Decoder.convertBoolArrayToByteArray(correctedBits);\n    var result = Decoder.getEncodedData(correctedBits);\n    var decoderResult = new DecoderResult_1.default(rawBytes, result, null, null);\n    decoderResult.setNumBits(correctedBits.length);\n    return decoderResult;\n  }; // This method is used for testing the high-level encoder\n\n\n  Decoder.highLevelDecode = function (correctedBits) {\n    return this.getEncodedData(correctedBits);\n  };\n  /**\n   * Gets the string encoded in the aztec code bits\n   *\n   * @return the decoded string\n   */\n\n\n  Decoder.getEncodedData = function (correctedBits) {\n    var endIndex = correctedBits.length;\n    var latchTable = Table.UPPER; // table most recently latched to\n\n    var shiftTable = Table.UPPER; // table to use for the next read\n\n    var result = '';\n    var index = 0;\n\n    while (index < endIndex) {\n      if (shiftTable === Table.BINARY) {\n        if (endIndex - index < 5) {\n          break;\n        }\n\n        var length_1 = Decoder.readCode(correctedBits, index, 5);\n        index += 5;\n\n        if (length_1 === 0) {\n          if (endIndex - index < 11) {\n            break;\n          }\n\n          length_1 = Decoder.readCode(correctedBits, index, 11) + 31;\n          index += 11;\n        }\n\n        for (var charCount = 0; charCount < length_1; charCount++) {\n          if (endIndex - index < 8) {\n            index = endIndex; // Force outer loop to exit\n\n            break;\n          }\n\n          var code = Decoder.readCode(correctedBits, index, 8);\n          result +=\n          /*(char)*/\n          __1.StringUtils.castAsNonUtf8Char(code);\n          index += 8;\n        } // Go back to whatever mode we had been in\n\n\n        shiftTable = latchTable;\n      } else {\n        var size = shiftTable === Table.DIGIT ? 4 : 5;\n\n        if (endIndex - index < size) {\n          break;\n        }\n\n        var code = Decoder.readCode(correctedBits, index, size);\n        index += size;\n        var str = Decoder.getCharacter(shiftTable, code);\n\n        if (str.startsWith('CTRL_')) {\n          // Table changes\n          // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.\n          // That's including when that mode is a shift.\n          // Our test case dlusbs.png for issue #642 exercises that.\n          latchTable = shiftTable; // Latch the current mode, so as to return to Upper after U/S B/S\n\n          shiftTable = Decoder.getTable(str.charAt(5));\n\n          if (str.charAt(6) === 'L') {\n            latchTable = shiftTable;\n          }\n        } else {\n          result += str; // Go back to whatever mode we had been in\n\n          shiftTable = latchTable;\n        }\n      }\n    }\n\n    return result;\n  };\n  /**\n   * gets the table corresponding to the char passed\n   */\n\n\n  Decoder.getTable = function (t) {\n    switch (t) {\n      case 'L':\n        return Table.LOWER;\n\n      case 'P':\n        return Table.PUNCT;\n\n      case 'M':\n        return Table.MIXED;\n\n      case 'D':\n        return Table.DIGIT;\n\n      case 'B':\n        return Table.BINARY;\n\n      case 'U':\n      default:\n        return Table.UPPER;\n    }\n  };\n  /**\n   * Gets the character (or string) corresponding to the passed code in the given table\n   *\n   * @param table the table used\n   * @param code the code of the character\n   */\n\n\n  Decoder.getCharacter = function (table, code) {\n    switch (table) {\n      case Table.UPPER:\n        return Decoder.UPPER_TABLE[code];\n\n      case Table.LOWER:\n        return Decoder.LOWER_TABLE[code];\n\n      case Table.MIXED:\n        return Decoder.MIXED_TABLE[code];\n\n      case Table.PUNCT:\n        return Decoder.PUNCT_TABLE[code];\n\n      case Table.DIGIT:\n        return Decoder.DIGIT_TABLE[code];\n\n      default:\n        // Should not reach here.\n        throw new IllegalStateException_1.default('Bad table');\n    }\n  };\n  /**\n   * <p>Performs RS error correction on an array of bits.</p>\n   *\n   * @return the corrected array\n   * @throws FormatException if the input contains too many errors\n   */\n\n\n  Decoder.prototype.correctBits = function (rawbits) {\n    var gf;\n    var codewordSize;\n\n    if (this.ddata.getNbLayers() <= 2) {\n      codewordSize = 6;\n      gf = GenericGF_1.default.AZTEC_DATA_6;\n    } else if (this.ddata.getNbLayers() <= 8) {\n      codewordSize = 8;\n      gf = GenericGF_1.default.AZTEC_DATA_8;\n    } else if (this.ddata.getNbLayers() <= 22) {\n      codewordSize = 10;\n      gf = GenericGF_1.default.AZTEC_DATA_10;\n    } else {\n      codewordSize = 12;\n      gf = GenericGF_1.default.AZTEC_DATA_12;\n    }\n\n    var numDataCodewords = this.ddata.getNbDatablocks();\n    var numCodewords = rawbits.length / codewordSize;\n\n    if (numCodewords < numDataCodewords) {\n      throw new FormatException_1.default();\n    }\n\n    var offset = rawbits.length % codewordSize;\n    var dataWords = new Int32Array(numCodewords);\n\n    for (var i = 0; i < numCodewords; i++, offset += codewordSize) {\n      dataWords[i] = Decoder.readCode(rawbits, offset, codewordSize);\n    }\n\n    try {\n      var rsDecoder = new ReedSolomonDecoder_1.default(gf);\n      rsDecoder.decode(dataWords, numCodewords - numDataCodewords);\n    } catch (ex) {\n      throw new FormatException_1.default(ex);\n    } // Now perform the unstuffing operation.\n    // First, count how many bits are going to be thrown out as stuffing\n\n\n    var mask = (1 << codewordSize) - 1;\n    var stuffedBits = 0;\n\n    for (var i = 0; i < numDataCodewords; i++) {\n      var dataWord = dataWords[i];\n\n      if (dataWord === 0 || dataWord === mask) {\n        throw new FormatException_1.default();\n      } else if (dataWord === 1 || dataWord === mask - 1) {\n        stuffedBits++;\n      }\n    } // Now, actually unpack the bits and remove the stuffing\n\n\n    var correctedBits = new Array(numDataCodewords * codewordSize - stuffedBits);\n    var index = 0;\n\n    for (var i = 0; i < numDataCodewords; i++) {\n      var dataWord = dataWords[i];\n\n      if (dataWord === 1 || dataWord === mask - 1) {\n        // next codewordSize-1 bits are all zeros or all ones\n        correctedBits.fill(dataWord > 1, index, index + codewordSize - 1); // Arrays.fill(correctedBits, index, index + codewordSize - 1, dataWord > 1);\n\n        index += codewordSize - 1;\n      } else {\n        for (var bit = codewordSize - 1; bit >= 0; --bit) {\n          correctedBits[index++] = (dataWord & 1 << bit) !== 0;\n        }\n      }\n    }\n\n    return correctedBits;\n  };\n  /**\n   * Gets the array of bits from an Aztec Code matrix\n   *\n   * @return the array of bits\n   */\n\n\n  Decoder.prototype.extractBits = function (matrix) {\n    var compact = this.ddata.isCompact();\n    var layers = this.ddata.getNbLayers();\n    var baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines\n\n    var alignmentMap = new Int32Array(baseMatrixSize);\n    var rawbits = new Array(this.totalBitsInLayer(layers, compact));\n\n    if (compact) {\n      for (var i = 0; i < alignmentMap.length; i++) {\n        alignmentMap[i] = i;\n      }\n    } else {\n      var matrixSize = baseMatrixSize + 1 + 2 * Integer_1.default.truncDivision(Integer_1.default.truncDivision(baseMatrixSize, 2) - 1, 15);\n      var origCenter = baseMatrixSize / 2;\n      var center = Integer_1.default.truncDivision(matrixSize, 2);\n\n      for (var i = 0; i < origCenter; i++) {\n        var newOffset = i + Integer_1.default.truncDivision(i, 15);\n        alignmentMap[origCenter - i - 1] = center - newOffset - 1;\n        alignmentMap[origCenter + i] = center + newOffset + 1;\n      }\n    }\n\n    for (var i = 0, rowOffset = 0; i < layers; i++) {\n      var rowSize = (layers - i) * 4 + (compact ? 9 : 12); // The top-left most point of this layer is <low, low> (not including alignment lines)\n\n      var low = i * 2; // The bottom-right most point of this layer is <high, high> (not including alignment lines)\n\n      var high = baseMatrixSize - 1 - low; // We pull bits from the two 2 x rowSize columns and two rowSize x 2 rows\n\n      for (var j = 0; j < rowSize; j++) {\n        var columnOffset = j * 2;\n\n        for (var k = 0; k < 2; k++) {\n          // left column\n          rawbits[rowOffset + columnOffset + k] = matrix.get(alignmentMap[low + k], alignmentMap[low + j]); // bottom row\n\n          rawbits[rowOffset + 2 * rowSize + columnOffset + k] = matrix.get(alignmentMap[low + j], alignmentMap[high - k]); // right column\n\n          rawbits[rowOffset + 4 * rowSize + columnOffset + k] = matrix.get(alignmentMap[high - k], alignmentMap[high - j]); // top row\n\n          rawbits[rowOffset + 6 * rowSize + columnOffset + k] = matrix.get(alignmentMap[high - j], alignmentMap[low + k]);\n        }\n      }\n\n      rowOffset += rowSize * 8;\n    }\n\n    return rawbits;\n  };\n  /**\n   * Reads a code of given length and at given index in an array of bits\n   */\n\n\n  Decoder.readCode = function (rawbits, startIndex, length) {\n    var res = 0;\n\n    for (var i = startIndex; i < startIndex + length; i++) {\n      res <<= 1;\n\n      if (rawbits[i]) {\n        res |= 0x01;\n      }\n    }\n\n    return res;\n  };\n  /**\n   * Reads a code of length 8 in an array of bits, padding with zeros\n   */\n\n\n  Decoder.readByte = function (rawbits, startIndex) {\n    var n = rawbits.length - startIndex;\n\n    if (n >= 8) {\n      return Decoder.readCode(rawbits, startIndex, 8);\n    }\n\n    return Decoder.readCode(rawbits, startIndex, n) << 8 - n;\n  };\n  /**\n   * Packs a bit array into bytes, most significant bit first\n   */\n\n\n  Decoder.convertBoolArrayToByteArray = function (boolArr) {\n    var byteArr = new Uint8Array((boolArr.length + 7) / 8);\n\n    for (var i = 0; i < byteArr.length; i++) {\n      byteArr[i] = Decoder.readByte(boolArr, 8 * i);\n    }\n\n    return byteArr;\n  };\n\n  Decoder.prototype.totalBitsInLayer = function (layers, compact) {\n    return ((compact ? 88 : 112) + 16 * layers) * layers;\n  };\n\n  Decoder.UPPER_TABLE = ['CTRL_PS', ' ', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'CTRL_LL', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'];\n  Decoder.LOWER_TABLE = ['CTRL_PS', ' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'CTRL_US', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'];\n  Decoder.MIXED_TABLE = [// Module parse failed: Octal literal in strict mode (50:29)\n  // so number string were scaped\n  'CTRL_PS', ' ', '\\\\1', '\\\\2', '\\\\3', '\\\\4', '\\\\5', '\\\\6', '\\\\7', '\\b', '\\t', '\\n', '\\\\13', '\\f', '\\r', '\\\\33', '\\\\34', '\\\\35', '\\\\36', '\\\\37', '@', '\\\\', '^', '_', '`', '|', '~', '\\\\177', 'CTRL_LL', 'CTRL_UL', 'CTRL_PL', 'CTRL_BS'];\n  Decoder.PUNCT_TABLE = ['', '\\r', '\\r\\n', '. ', ', ', ': ', '!', '\"', '#', '$', '%', '&', '\\'', '(', ')', '*', '+', ',', '-', '.', '/', ':', ';', '<', '=', '>', '?', '[', ']', '{', '}', 'CTRL_UL'];\n  Decoder.DIGIT_TABLE = ['CTRL_PS', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', '.', 'CTRL_UL', 'CTRL_US'];\n  return Decoder;\n}();\n\nexports.default = Decoder;","map":{"version":3,"sources":["../../../../src/core/aztec/decoder/Decoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DecoderResult_1 = require(\"../../common/DecoderResult\");\nvar GenericGF_1 = require(\"../../common/reedsolomon/GenericGF\");\nvar ReedSolomonDecoder_1 = require(\"../../common/reedsolomon/ReedSolomonDecoder\");\nvar IllegalStateException_1 = require(\"../../IllegalStateException\");\nvar FormatException_1 = require(\"../../FormatException\");\nvar __1 = require(\"../../..\");\nvar Integer_1 = require(\"../../util/Integer\");\n// import java.util.Arrays;\nvar Table;\n(function (Table) {\n    Table[Table[\"UPPER\"] = 0] = \"UPPER\";\n    Table[Table[\"LOWER\"] = 1] = \"LOWER\";\n    Table[Table[\"MIXED\"] = 2] = \"MIXED\";\n    Table[Table[\"DIGIT\"] = 3] = \"DIGIT\";\n    Table[Table[\"PUNCT\"] = 4] = \"PUNCT\";\n    Table[Table[\"BINARY\"] = 5] = \"BINARY\";\n})(Table || (Table = {}));\n/**\n * <p>The main class which implements Aztec Code decoding -- as opposed to locating and extracting\n * the Aztec Code from an image.</p>\n *\n * @author David Olivier\n */\nvar Decoder = /** @class */ (function () {\n    function Decoder() {\n    }\n    Decoder.prototype.decode = function (detectorResult) {\n        this.ddata = detectorResult;\n        var matrix = detectorResult.getBits();\n        var rawbits = this.extractBits(matrix);\n        var correctedBits = this.correctBits(rawbits);\n        var rawBytes = Decoder.convertBoolArrayToByteArray(correctedBits);\n        var result = Decoder.getEncodedData(correctedBits);\n        var decoderResult = new DecoderResult_1.default(rawBytes, result, null, null);\n        decoderResult.setNumBits(correctedBits.length);\n        return decoderResult;\n    };\n    // This method is used for testing the high-level encoder\n    Decoder.highLevelDecode = function (correctedBits) {\n        return this.getEncodedData(correctedBits);\n    };\n    /**\n     * Gets the string encoded in the aztec code bits\n     *\n     * @return the decoded string\n     */\n    Decoder.getEncodedData = function (correctedBits) {\n        var endIndex = correctedBits.length;\n        var latchTable = Table.UPPER; // table most recently latched to\n        var shiftTable = Table.UPPER; // table to use for the next read\n        var result = '';\n        var index = 0;\n        while (index < endIndex) {\n            if (shiftTable === Table.BINARY) {\n                if (endIndex - index < 5) {\n                    break;\n                }\n                var length_1 = Decoder.readCode(correctedBits, index, 5);\n                index += 5;\n                if (length_1 === 0) {\n                    if (endIndex - index < 11) {\n                        break;\n                    }\n                    length_1 = Decoder.readCode(correctedBits, index, 11) + 31;\n                    index += 11;\n                }\n                for (var charCount = 0; charCount < length_1; charCount++) {\n                    if (endIndex - index < 8) {\n                        index = endIndex; // Force outer loop to exit\n                        break;\n                    }\n                    var code = Decoder.readCode(correctedBits, index, 8);\n                    result += /*(char)*/ __1.StringUtils.castAsNonUtf8Char(code);\n                    index += 8;\n                }\n                // Go back to whatever mode we had been in\n                shiftTable = latchTable;\n            }\n            else {\n                var size = shiftTable === Table.DIGIT ? 4 : 5;\n                if (endIndex - index < size) {\n                    break;\n                }\n                var code = Decoder.readCode(correctedBits, index, size);\n                index += size;\n                var str = Decoder.getCharacter(shiftTable, code);\n                if (str.startsWith('CTRL_')) {\n                    // Table changes\n                    // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.\n                    // That's including when that mode is a shift.\n                    // Our test case dlusbs.png for issue #642 exercises that.\n                    latchTable = shiftTable; // Latch the current mode, so as to return to Upper after U/S B/S\n                    shiftTable = Decoder.getTable(str.charAt(5));\n                    if (str.charAt(6) === 'L') {\n                        latchTable = shiftTable;\n                    }\n                }\n                else {\n                    result += str;\n                    // Go back to whatever mode we had been in\n                    shiftTable = latchTable;\n                }\n            }\n        }\n        return result;\n    };\n    /**\n     * gets the table corresponding to the char passed\n     */\n    Decoder.getTable = function (t) {\n        switch (t) {\n            case 'L':\n                return Table.LOWER;\n            case 'P':\n                return Table.PUNCT;\n            case 'M':\n                return Table.MIXED;\n            case 'D':\n                return Table.DIGIT;\n            case 'B':\n                return Table.BINARY;\n            case 'U':\n            default:\n                return Table.UPPER;\n        }\n    };\n    /**\n     * Gets the character (or string) corresponding to the passed code in the given table\n     *\n     * @param table the table used\n     * @param code the code of the character\n     */\n    Decoder.getCharacter = function (table, code) {\n        switch (table) {\n            case Table.UPPER:\n                return Decoder.UPPER_TABLE[code];\n            case Table.LOWER:\n                return Decoder.LOWER_TABLE[code];\n            case Table.MIXED:\n                return Decoder.MIXED_TABLE[code];\n            case Table.PUNCT:\n                return Decoder.PUNCT_TABLE[code];\n            case Table.DIGIT:\n                return Decoder.DIGIT_TABLE[code];\n            default:\n                // Should not reach here.\n                throw new IllegalStateException_1.default('Bad table');\n        }\n    };\n    /**\n     * <p>Performs RS error correction on an array of bits.</p>\n     *\n     * @return the corrected array\n     * @throws FormatException if the input contains too many errors\n     */\n    Decoder.prototype.correctBits = function (rawbits) {\n        var gf;\n        var codewordSize;\n        if (this.ddata.getNbLayers() <= 2) {\n            codewordSize = 6;\n            gf = GenericGF_1.default.AZTEC_DATA_6;\n        }\n        else if (this.ddata.getNbLayers() <= 8) {\n            codewordSize = 8;\n            gf = GenericGF_1.default.AZTEC_DATA_8;\n        }\n        else if (this.ddata.getNbLayers() <= 22) {\n            codewordSize = 10;\n            gf = GenericGF_1.default.AZTEC_DATA_10;\n        }\n        else {\n            codewordSize = 12;\n            gf = GenericGF_1.default.AZTEC_DATA_12;\n        }\n        var numDataCodewords = this.ddata.getNbDatablocks();\n        var numCodewords = rawbits.length / codewordSize;\n        if (numCodewords < numDataCodewords) {\n            throw new FormatException_1.default();\n        }\n        var offset = rawbits.length % codewordSize;\n        var dataWords = new Int32Array(numCodewords);\n        for (var i = 0; i < numCodewords; i++, offset += codewordSize) {\n            dataWords[i] = Decoder.readCode(rawbits, offset, codewordSize);\n        }\n        try {\n            var rsDecoder = new ReedSolomonDecoder_1.default(gf);\n            rsDecoder.decode(dataWords, numCodewords - numDataCodewords);\n        }\n        catch (ex) {\n            throw new FormatException_1.default(ex);\n        }\n        // Now perform the unstuffing operation.\n        // First, count how many bits are going to be thrown out as stuffing\n        var mask = (1 << codewordSize) - 1;\n        var stuffedBits = 0;\n        for (var i = 0; i < numDataCodewords; i++) {\n            var dataWord = dataWords[i];\n            if (dataWord === 0 || dataWord === mask) {\n                throw new FormatException_1.default();\n            }\n            else if (dataWord === 1 || dataWord === mask - 1) {\n                stuffedBits++;\n            }\n        }\n        // Now, actually unpack the bits and remove the stuffing\n        var correctedBits = new Array(numDataCodewords * codewordSize - stuffedBits);\n        var index = 0;\n        for (var i = 0; i < numDataCodewords; i++) {\n            var dataWord = dataWords[i];\n            if (dataWord === 1 || dataWord === mask - 1) {\n                // next codewordSize-1 bits are all zeros or all ones\n                correctedBits.fill(dataWord > 1, index, index + codewordSize - 1);\n                // Arrays.fill(correctedBits, index, index + codewordSize - 1, dataWord > 1);\n                index += codewordSize - 1;\n            }\n            else {\n                for (var bit = codewordSize - 1; bit >= 0; --bit) {\n                    correctedBits[index++] = (dataWord & (1 << bit)) !== 0;\n                }\n            }\n        }\n        return correctedBits;\n    };\n    /**\n     * Gets the array of bits from an Aztec Code matrix\n     *\n     * @return the array of bits\n     */\n    Decoder.prototype.extractBits = function (matrix) {\n        var compact = this.ddata.isCompact();\n        var layers = this.ddata.getNbLayers();\n        var baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines\n        var alignmentMap = new Int32Array(baseMatrixSize);\n        var rawbits = new Array(this.totalBitsInLayer(layers, compact));\n        if (compact) {\n            for (var i = 0; i < alignmentMap.length; i++) {\n                alignmentMap[i] = i;\n            }\n        }\n        else {\n            var matrixSize = baseMatrixSize + 1 + 2 * Integer_1.default.truncDivision((Integer_1.default.truncDivision(baseMatrixSize, 2) - 1), 15);\n            var origCenter = baseMatrixSize / 2;\n            var center = Integer_1.default.truncDivision(matrixSize, 2);\n            for (var i = 0; i < origCenter; i++) {\n                var newOffset = i + Integer_1.default.truncDivision(i, 15);\n                alignmentMap[origCenter - i - 1] = center - newOffset - 1;\n                alignmentMap[origCenter + i] = center + newOffset + 1;\n            }\n        }\n        for (var i = 0, rowOffset = 0; i < layers; i++) {\n            var rowSize = (layers - i) * 4 + (compact ? 9 : 12);\n            // The top-left most point of this layer is <low, low> (not including alignment lines)\n            var low = i * 2;\n            // The bottom-right most point of this layer is <high, high> (not including alignment lines)\n            var high = baseMatrixSize - 1 - low;\n            // We pull bits from the two 2 x rowSize columns and two rowSize x 2 rows\n            for (var j = 0; j < rowSize; j++) {\n                var columnOffset = j * 2;\n                for (var k = 0; k < 2; k++) {\n                    // left column\n                    rawbits[rowOffset + columnOffset + k] =\n                        matrix.get(alignmentMap[low + k], alignmentMap[low + j]);\n                    // bottom row\n                    rawbits[rowOffset + 2 * rowSize + columnOffset + k] =\n                        matrix.get(alignmentMap[low + j], alignmentMap[high - k]);\n                    // right column\n                    rawbits[rowOffset + 4 * rowSize + columnOffset + k] =\n                        matrix.get(alignmentMap[high - k], alignmentMap[high - j]);\n                    // top row\n                    rawbits[rowOffset + 6 * rowSize + columnOffset + k] =\n                        matrix.get(alignmentMap[high - j], alignmentMap[low + k]);\n                }\n            }\n            rowOffset += rowSize * 8;\n        }\n        return rawbits;\n    };\n    /**\n     * Reads a code of given length and at given index in an array of bits\n     */\n    Decoder.readCode = function (rawbits, startIndex, length) {\n        var res = 0;\n        for (var i = startIndex; i < startIndex + length; i++) {\n            res <<= 1;\n            if (rawbits[i]) {\n                res |= 0x01;\n            }\n        }\n        return res;\n    };\n    /**\n     * Reads a code of length 8 in an array of bits, padding with zeros\n     */\n    Decoder.readByte = function (rawbits, startIndex) {\n        var n = rawbits.length - startIndex;\n        if (n >= 8) {\n            return Decoder.readCode(rawbits, startIndex, 8);\n        }\n        return Decoder.readCode(rawbits, startIndex, n) << (8 - n);\n    };\n    /**\n     * Packs a bit array into bytes, most significant bit first\n     */\n    Decoder.convertBoolArrayToByteArray = function (boolArr) {\n        var byteArr = new Uint8Array((boolArr.length + 7) / 8);\n        for (var i = 0; i < byteArr.length; i++) {\n            byteArr[i] = Decoder.readByte(boolArr, 8 * i);\n        }\n        return byteArr;\n    };\n    Decoder.prototype.totalBitsInLayer = function (layers, compact) {\n        return ((compact ? 88 : 112) + 16 * layers) * layers;\n    };\n    Decoder.UPPER_TABLE = [\n        'CTRL_PS', ' ', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',\n        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'CTRL_LL', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'\n    ];\n    Decoder.LOWER_TABLE = [\n        'CTRL_PS', ' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',\n        'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'CTRL_US', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'\n    ];\n    Decoder.MIXED_TABLE = [\n        // Module parse failed: Octal literal in strict mode (50:29)\n        // so number string were scaped\n        'CTRL_PS', ' ', '\\\\1', '\\\\2', '\\\\3', '\\\\4', '\\\\5', '\\\\6', '\\\\7', '\\b', '\\t', '\\n',\n        '\\\\13', '\\f', '\\r', '\\\\33', '\\\\34', '\\\\35', '\\\\36', '\\\\37', '@', '\\\\', '^', '_',\n        '`', '|', '~', '\\\\177', 'CTRL_LL', 'CTRL_UL', 'CTRL_PL', 'CTRL_BS'\n    ];\n    Decoder.PUNCT_TABLE = [\n        '', '\\r', '\\r\\n', '. ', ', ', ': ', '!', '\"', '#', '$', '%', '&', '\\'', '(', ')',\n        '*', '+', ',', '-', '.', '/', ':', ';', '<', '=', '>', '?', '[', ']', '{', '}', 'CTRL_UL'\n    ];\n    Decoder.DIGIT_TABLE = [\n        'CTRL_PS', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', '.', 'CTRL_UL', 'CTRL_US'\n    ];\n    return Decoder;\n}());\nexports.default = Decoder;\n//# sourceMappingURL=Decoder.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\n* Copyright 2012 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // package com.google.zxing.pdf417.decoder.ec;\n// import com.google.zxing.ChecksumException;\n\nvar ChecksumException_1 = require(\"../../../ChecksumException\");\n\nvar ModulusPoly_1 = require(\"./ModulusPoly\");\n\nvar ModulusGF_1 = require(\"./ModulusGF\");\n/**\n * <p>PDF417 error correction implementation.</p>\n *\n * <p>This <a href=\"http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example\">example</a>\n * is quite useful in understanding the algorithm.</p>\n *\n * @author Sean Owen\n * @see com.google.zxing.common.reedsolomon.ReedSolomonDecoder\n */\n\n\nvar ErrorCorrection =\n/** @class */\nfunction () {\n  function ErrorCorrection() {\n    this.field = ModulusGF_1.default.PDF417_GF;\n  }\n  /**\n   * @param received received codewords\n   * @param numECCodewords number of those codewords used for EC\n   * @param erasures location of erasures\n   * @return number of errors\n   * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors\n   */\n\n\n  ErrorCorrection.prototype.decode = function (received, numECCodewords, erasures) {\n    var e_1, _a;\n\n    var poly = new ModulusPoly_1.default(this.field, received);\n    var S = new Int32Array(numECCodewords);\n    var error = false;\n\n    for (var i\n    /*int*/\n    = numECCodewords; i > 0; i--) {\n      var evaluation = poly.evaluateAt(this.field.exp(i));\n      S[numECCodewords - i] = evaluation;\n\n      if (evaluation !== 0) {\n        error = true;\n      }\n    }\n\n    if (!error) {\n      return 0;\n    }\n\n    var knownErrors = this.field.getOne();\n\n    if (erasures != null) {\n      try {\n        for (var erasures_1 = __values(erasures), erasures_1_1 = erasures_1.next(); !erasures_1_1.done; erasures_1_1 = erasures_1.next()) {\n          var erasure = erasures_1_1.value;\n          var b = this.field.exp(received.length - 1 - erasure); // Add (1 - bx) term:\n\n          var term = new ModulusPoly_1.default(this.field, new Int32Array([this.field.subtract(0, b), 1]));\n          knownErrors = knownErrors.multiply(term);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (erasures_1_1 && !erasures_1_1.done && (_a = erasures_1.return)) _a.call(erasures_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    var syndrome = new ModulusPoly_1.default(this.field, S); // syndrome = syndrome.multiply(knownErrors);\n\n    var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);\n    var sigma = sigmaOmega[0];\n    var omega = sigmaOmega[1]; // sigma = sigma.multiply(knownErrors);\n\n    var errorLocations = this.findErrorLocations(sigma);\n    var errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);\n\n    for (var i\n    /*int*/\n    = 0; i < errorLocations.length; i++) {\n      var position = received.length - 1 - this.field.log(errorLocations[i]);\n\n      if (position < 0) {\n        throw ChecksumException_1.default.getChecksumInstance();\n      }\n\n      received[position] = this.field.subtract(received[position], errorMagnitudes[i]);\n    }\n\n    return errorLocations.length;\n  };\n  /**\n   *\n   * @param ModulusPoly\n   * @param a\n   * @param ModulusPoly\n   * @param b\n   * @param int\n   * @param R\n   * @throws ChecksumException\n   */\n\n\n  ErrorCorrection.prototype.runEuclideanAlgorithm = function (a, b, R) {\n    // Assume a's degree is >= b's\n    if (a.getDegree() < b.getDegree()) {\n      var temp = a;\n      a = b;\n      b = temp;\n    }\n\n    var rLast = a;\n    var r = b;\n    var tLast = this.field.getZero();\n    var t = this.field.getOne(); // Run Euclidean algorithm until r's degree is less than R/2\n\n    while (r.getDegree() >= Math.round(R / 2)) {\n      var rLastLast = rLast;\n      var tLastLast = tLast;\n      rLast = r;\n      tLast = t; // Divide rLastLast by rLast, with quotient in q and remainder in r\n\n      if (rLast.isZero()) {\n        // Oops, Euclidean algorithm already terminated?\n        throw ChecksumException_1.default.getChecksumInstance();\n      }\n\n      r = rLastLast;\n      var q = this.field.getZero();\n      var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n      var dltInverse = this.field.inverse(denominatorLeadingTerm);\n\n      while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\n        var degreeDiff = r.getDegree() - rLast.getDegree();\n        var scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n        q = q.add(this.field.buildMonomial(degreeDiff, scale));\n        r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));\n      }\n\n      t = q.multiply(tLast).subtract(tLastLast).negative();\n    }\n\n    var sigmaTildeAtZero = t.getCoefficient(0);\n\n    if (sigmaTildeAtZero === 0) {\n      throw ChecksumException_1.default.getChecksumInstance();\n    }\n\n    var inverse = this.field.inverse(sigmaTildeAtZero);\n    var sigma = t.multiply(inverse);\n    var omega = r.multiply(inverse);\n    return [sigma, omega];\n  };\n  /**\n   *\n   * @param errorLocator\n   * @throws ChecksumException\n   */\n\n\n  ErrorCorrection.prototype.findErrorLocations = function (errorLocator) {\n    // This is a direct application of Chien's search\n    var numErrors = errorLocator.getDegree();\n    var result = new Int32Array(numErrors);\n    var e = 0;\n\n    for (var i\n    /*int*/\n    = 1; i < this.field.getSize() && e < numErrors; i++) {\n      if (errorLocator.evaluateAt(i) === 0) {\n        result[e] = this.field.inverse(i);\n        e++;\n      }\n    }\n\n    if (e !== numErrors) {\n      throw ChecksumException_1.default.getChecksumInstance();\n    }\n\n    return result;\n  };\n\n  ErrorCorrection.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocator, errorLocations) {\n    var errorLocatorDegree = errorLocator.getDegree();\n    var formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);\n\n    for (var i\n    /*int*/\n    = 1; i <= errorLocatorDegree; i++) {\n      formalDerivativeCoefficients[errorLocatorDegree - i] = this.field.multiply(i, errorLocator.getCoefficient(i));\n    }\n\n    var formalDerivative = new ModulusPoly_1.default(this.field, formalDerivativeCoefficients); // This is directly applying Forney's Formula\n\n    var s = errorLocations.length;\n    var result = new Int32Array(s);\n\n    for (var i\n    /*int*/\n    = 0; i < s; i++) {\n      var xiInverse = this.field.inverse(errorLocations[i]);\n      var numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));\n      var denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));\n      result[i] = this.field.multiply(numerator, denominator);\n    }\n\n    return result;\n  };\n\n  return ErrorCorrection;\n}();\n\nexports.default = ErrorCorrection;","map":{"version":3,"sources":["../../../../../src/core/pdf417/decoder/ec/ErrorCorrection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n* Copyright 2012 ZXing authors\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// package com.google.zxing.pdf417.decoder.ec;\n// import com.google.zxing.ChecksumException;\nvar ChecksumException_1 = require(\"../../../ChecksumException\");\nvar ModulusPoly_1 = require(\"./ModulusPoly\");\nvar ModulusGF_1 = require(\"./ModulusGF\");\n/**\n * <p>PDF417 error correction implementation.</p>\n *\n * <p>This <a href=\"http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example\">example</a>\n * is quite useful in understanding the algorithm.</p>\n *\n * @author Sean Owen\n * @see com.google.zxing.common.reedsolomon.ReedSolomonDecoder\n */\nvar ErrorCorrection = /** @class */ (function () {\n    function ErrorCorrection() {\n        this.field = ModulusGF_1.default.PDF417_GF;\n    }\n    /**\n     * @param received received codewords\n     * @param numECCodewords number of those codewords used for EC\n     * @param erasures location of erasures\n     * @return number of errors\n     * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors\n     */\n    ErrorCorrection.prototype.decode = function (received, numECCodewords, erasures) {\n        var e_1, _a;\n        var poly = new ModulusPoly_1.default(this.field, received);\n        var S = new Int32Array(numECCodewords);\n        var error = false;\n        for (var i /*int*/ = numECCodewords; i > 0; i--) {\n            var evaluation = poly.evaluateAt(this.field.exp(i));\n            S[numECCodewords - i] = evaluation;\n            if (evaluation !== 0) {\n                error = true;\n            }\n        }\n        if (!error) {\n            return 0;\n        }\n        var knownErrors = this.field.getOne();\n        if (erasures != null) {\n            try {\n                for (var erasures_1 = __values(erasures), erasures_1_1 = erasures_1.next(); !erasures_1_1.done; erasures_1_1 = erasures_1.next()) {\n                    var erasure = erasures_1_1.value;\n                    var b = this.field.exp(received.length - 1 - erasure);\n                    // Add (1 - bx) term:\n                    var term = new ModulusPoly_1.default(this.field, new Int32Array([this.field.subtract(0, b), 1]));\n                    knownErrors = knownErrors.multiply(term);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (erasures_1_1 && !erasures_1_1.done && (_a = erasures_1.return)) _a.call(erasures_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        var syndrome = new ModulusPoly_1.default(this.field, S);\n        // syndrome = syndrome.multiply(knownErrors);\n        var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);\n        var sigma = sigmaOmega[0];\n        var omega = sigmaOmega[1];\n        // sigma = sigma.multiply(knownErrors);\n        var errorLocations = this.findErrorLocations(sigma);\n        var errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);\n        for (var i /*int*/ = 0; i < errorLocations.length; i++) {\n            var position = received.length - 1 - this.field.log(errorLocations[i]);\n            if (position < 0) {\n                throw ChecksumException_1.default.getChecksumInstance();\n            }\n            received[position] = this.field.subtract(received[position], errorMagnitudes[i]);\n        }\n        return errorLocations.length;\n    };\n    /**\n     *\n     * @param ModulusPoly\n     * @param a\n     * @param ModulusPoly\n     * @param b\n     * @param int\n     * @param R\n     * @throws ChecksumException\n     */\n    ErrorCorrection.prototype.runEuclideanAlgorithm = function (a, b, R) {\n        // Assume a's degree is >= b's\n        if (a.getDegree() < b.getDegree()) {\n            var temp = a;\n            a = b;\n            b = temp;\n        }\n        var rLast = a;\n        var r = b;\n        var tLast = this.field.getZero();\n        var t = this.field.getOne();\n        // Run Euclidean algorithm until r's degree is less than R/2\n        while (r.getDegree() >= Math.round(R / 2)) {\n            var rLastLast = rLast;\n            var tLastLast = tLast;\n            rLast = r;\n            tLast = t;\n            // Divide rLastLast by rLast, with quotient in q and remainder in r\n            if (rLast.isZero()) {\n                // Oops, Euclidean algorithm already terminated?\n                throw ChecksumException_1.default.getChecksumInstance();\n            }\n            r = rLastLast;\n            var q = this.field.getZero();\n            var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n            var dltInverse = this.field.inverse(denominatorLeadingTerm);\n            while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\n                var degreeDiff = r.getDegree() - rLast.getDegree();\n                var scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n                q = q.add(this.field.buildMonomial(degreeDiff, scale));\n                r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));\n            }\n            t = q.multiply(tLast).subtract(tLastLast).negative();\n        }\n        var sigmaTildeAtZero = t.getCoefficient(0);\n        if (sigmaTildeAtZero === 0) {\n            throw ChecksumException_1.default.getChecksumInstance();\n        }\n        var inverse = this.field.inverse(sigmaTildeAtZero);\n        var sigma = t.multiply(inverse);\n        var omega = r.multiply(inverse);\n        return [sigma, omega];\n    };\n    /**\n     *\n     * @param errorLocator\n     * @throws ChecksumException\n     */\n    ErrorCorrection.prototype.findErrorLocations = function (errorLocator) {\n        // This is a direct application of Chien's search\n        var numErrors = errorLocator.getDegree();\n        var result = new Int32Array(numErrors);\n        var e = 0;\n        for (var i /*int*/ = 1; i < this.field.getSize() && e < numErrors; i++) {\n            if (errorLocator.evaluateAt(i) === 0) {\n                result[e] = this.field.inverse(i);\n                e++;\n            }\n        }\n        if (e !== numErrors) {\n            throw ChecksumException_1.default.getChecksumInstance();\n        }\n        return result;\n    };\n    ErrorCorrection.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocator, errorLocations) {\n        var errorLocatorDegree = errorLocator.getDegree();\n        var formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);\n        for (var i /*int*/ = 1; i <= errorLocatorDegree; i++) {\n            formalDerivativeCoefficients[errorLocatorDegree - i] =\n                this.field.multiply(i, errorLocator.getCoefficient(i));\n        }\n        var formalDerivative = new ModulusPoly_1.default(this.field, formalDerivativeCoefficients);\n        // This is directly applying Forney's Formula\n        var s = errorLocations.length;\n        var result = new Int32Array(s);\n        for (var i /*int*/ = 0; i < s; i++) {\n            var xiInverse = this.field.inverse(errorLocations[i]);\n            var numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));\n            var denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));\n            result[i] = this.field.multiply(numerator, denominator);\n        }\n        return result;\n    };\n    return ErrorCorrection;\n}());\nexports.default = ErrorCorrection;\n//# sourceMappingURL=ErrorCorrection.js.map"]},"metadata":{},"sourceType":"script"}
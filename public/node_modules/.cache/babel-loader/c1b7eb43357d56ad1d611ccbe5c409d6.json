{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common {*/\n\n/*import java.util.Arrays;*/\n\nvar BitArray_1 = require(\"./BitArray\");\n\nvar System_1 = require(\"../util/System\");\n\nvar Arrays_1 = require(\"../util/Arrays\");\n\nvar StringBuilder_1 = require(\"../util/StringBuilder\");\n\nvar IllegalArgumentException_1 = require(\"../IllegalArgumentException\");\n/**\n * <p>Represents a 2D matrix of bits. In function arguments below, and throughout the common\n * module, x is the column position, and y is the row position. The ordering is always x, y.\n * The origin is at the top-left.</p>\n *\n * <p>Internally the bits are represented in a 1-D array of 32-bit ints. However, each row begins\n * with a new int. This is done intentionally so that we can copy out a row into a BitArray very\n * efficiently.</p>\n *\n * <p>The ordering of bits is row-major. Within each int, the least significant bits are used first,\n * meaning they represent lower x values. This is compatible with BitArray's implementation.</p>\n *\n * @author Sean Owen\n * @author dswitkin@google.com (Daniel Switkin)\n */\n\n\nvar BitMatrix\n/*implements Cloneable*/\n=\n/** @class */\nfunction () {\n  /**\n   * Creates an empty square {@link BitMatrix}.\n   *\n   * @param dimension height and width\n   */\n  // public constructor(dimension: number /*int*/) {\n  //   this(dimension, dimension)\n  // }\n\n  /**\n   * Creates an empty {@link BitMatrix}.\n   *\n   * @param width bit matrix width\n   * @param height bit matrix height\n   */\n  // public constructor(width: number /*int*/, height: number /*int*/) {\n  //   if (width < 1 || height < 1) {\n  //     throw new IllegalArgumentException(\"Both dimensions must be greater than 0\")\n  //   }\n  //   this.width = width\n  //   this.height = height\n  //   this.rowSize = (width + 31) / 32\n  //   bits = new int[rowSize * height];\n  // }\n  function BitMatrix(width\n  /*int*/\n  , height\n  /*int*/\n  , rowSize\n  /*int*/\n  , bits) {\n    this.width = width;\n    this.height = height;\n    this.rowSize = rowSize;\n    this.bits = bits;\n\n    if (undefined === height || null === height) {\n      height = width;\n    }\n\n    this.height = height;\n\n    if (width < 1 || height < 1) {\n      throw new IllegalArgumentException_1.default('Both dimensions must be greater than 0');\n    }\n\n    if (undefined === rowSize || null === rowSize) {\n      rowSize = Math.floor((width + 31) / 32);\n    }\n\n    this.rowSize = rowSize;\n\n    if (undefined === bits || null === bits) {\n      this.bits = new Int32Array(this.rowSize * this.height);\n    }\n  }\n  /**\n   * Interprets a 2D array of booleans as a {@link BitMatrix}, where \"true\" means an \"on\" bit.\n   *\n   * @function parse\n   * @param image bits of the image, as a row-major 2D array. Elements are arrays representing rows\n   * @return {@link BitMatrix} representation of image\n   */\n\n\n  BitMatrix.parseFromBooleanArray = function (image) {\n    var height = image.length;\n    var width = image[0].length;\n    var bits = new BitMatrix(width, height);\n\n    for (var i = 0; i < height; i++) {\n      var imageI = image[i];\n\n      for (var j = 0; j < width; j++) {\n        if (imageI[j]) {\n          bits.set(j, i);\n        }\n      }\n    }\n\n    return bits;\n  };\n  /**\n   *\n   * @function parse\n   * @param stringRepresentation\n   * @param setString\n   * @param unsetString\n   */\n\n\n  BitMatrix.parseFromString = function (stringRepresentation, setString, unsetString) {\n    if (stringRepresentation === null) {\n      throw new IllegalArgumentException_1.default('stringRepresentation cannot be null');\n    }\n\n    var bits = new Array(stringRepresentation.length);\n    var bitsPos = 0;\n    var rowStartPos = 0;\n    var rowLength = -1;\n    var nRows = 0;\n    var pos = 0;\n\n    while (pos < stringRepresentation.length) {\n      if (stringRepresentation.charAt(pos) === '\\n' || stringRepresentation.charAt(pos) === '\\r') {\n        if (bitsPos > rowStartPos) {\n          if (rowLength === -1) {\n            rowLength = bitsPos - rowStartPos;\n          } else if (bitsPos - rowStartPos !== rowLength) {\n            throw new IllegalArgumentException_1.default('row lengths do not match');\n          }\n\n          rowStartPos = bitsPos;\n          nRows++;\n        }\n\n        pos++;\n      } else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {\n        pos += setString.length;\n        bits[bitsPos] = true;\n        bitsPos++;\n      } else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {\n        pos += unsetString.length;\n        bits[bitsPos] = false;\n        bitsPos++;\n      } else {\n        throw new IllegalArgumentException_1.default('illegal character encountered: ' + stringRepresentation.substring(pos));\n      }\n    } // no EOL at end?\n\n\n    if (bitsPos > rowStartPos) {\n      if (rowLength === -1) {\n        rowLength = bitsPos - rowStartPos;\n      } else if (bitsPos - rowStartPos !== rowLength) {\n        throw new IllegalArgumentException_1.default('row lengths do not match');\n      }\n\n      nRows++;\n    }\n\n    var matrix = new BitMatrix(rowLength, nRows);\n\n    for (var i = 0; i < bitsPos; i++) {\n      if (bits[i]) {\n        matrix.set(Math.floor(i % rowLength), Math.floor(i / rowLength));\n      }\n    }\n\n    return matrix;\n  };\n  /**\n   * <p>Gets the requested bit, where true means black.</p>\n   *\n   * @param x The horizontal component (i.e. which column)\n   * @param y The vertical component (i.e. which row)\n   * @return value of given bit in matrix\n   */\n\n\n  BitMatrix.prototype.get = function (x\n  /*int*/\n  , y\n  /*int*/\n  ) {\n    var offset = y * this.rowSize + Math.floor(x / 32);\n    return (this.bits[offset] >>> (x & 0x1f) & 1) !== 0;\n  };\n  /**\n   * <p>Sets the given bit to true.</p>\n   *\n   * @param x The horizontal component (i.e. which column)\n   * @param y The vertical component (i.e. which row)\n   */\n\n\n  BitMatrix.prototype.set = function (x\n  /*int*/\n  , y\n  /*int*/\n  ) {\n    var offset = y * this.rowSize + Math.floor(x / 32);\n    this.bits[offset] |= 1 << (x & 0x1f) & 0xFFFFFFFF;\n  };\n\n  BitMatrix.prototype.unset = function (x\n  /*int*/\n  , y\n  /*int*/\n  ) {\n    var offset = y * this.rowSize + Math.floor(x / 32);\n    this.bits[offset] &= ~(1 << (x & 0x1f) & 0xFFFFFFFF);\n  };\n  /**\n   * <p>Flips the given bit.</p>\n   *\n   * @param x The horizontal component (i.e. which column)\n   * @param y The vertical component (i.e. which row)\n   */\n\n\n  BitMatrix.prototype.flip = function (x\n  /*int*/\n  , y\n  /*int*/\n  ) {\n    var offset = y * this.rowSize + Math.floor(x / 32);\n    this.bits[offset] ^= 1 << (x & 0x1f) & 0xFFFFFFFF;\n  };\n  /**\n   * Exclusive-or (XOR): Flip the bit in this {@code BitMatrix} if the corresponding\n   * mask bit is set.\n   *\n   * @param mask XOR mask\n   */\n\n\n  BitMatrix.prototype.xor = function (mask) {\n    if (this.width !== mask.getWidth() || this.height !== mask.getHeight() || this.rowSize !== mask.getRowSize()) {\n      throw new IllegalArgumentException_1.default('input matrix dimensions do not match');\n    }\n\n    var rowArray = new BitArray_1.default(Math.floor(this.width / 32) + 1);\n    var rowSize = this.rowSize;\n    var bits = this.bits;\n\n    for (var y = 0, height = this.height; y < height; y++) {\n      var offset = y * rowSize;\n      var row = mask.getRow(y, rowArray).getBitArray();\n\n      for (var x = 0; x < rowSize; x++) {\n        bits[offset + x] ^= row[x];\n      }\n    }\n  };\n  /**\n   * Clears all bits (sets to false).\n   */\n\n\n  BitMatrix.prototype.clear = function () {\n    var bits = this.bits;\n    var max = bits.length;\n\n    for (var i = 0; i < max; i++) {\n      bits[i] = 0;\n    }\n  };\n  /**\n   * <p>Sets a square region of the bit matrix to true.</p>\n   *\n   * @param left The horizontal position to begin at (inclusive)\n   * @param top The vertical position to begin at (inclusive)\n   * @param width The width of the region\n   * @param height The height of the region\n   */\n\n\n  BitMatrix.prototype.setRegion = function (left\n  /*int*/\n  , top\n  /*int*/\n  , width\n  /*int*/\n  , height\n  /*int*/\n  ) {\n    if (top < 0 || left < 0) {\n      throw new IllegalArgumentException_1.default('Left and top must be nonnegative');\n    }\n\n    if (height < 1 || width < 1) {\n      throw new IllegalArgumentException_1.default('Height and width must be at least 1');\n    }\n\n    var right = left + width;\n    var bottom = top + height;\n\n    if (bottom > this.height || right > this.width) {\n      throw new IllegalArgumentException_1.default('The region must fit inside the matrix');\n    }\n\n    var rowSize = this.rowSize;\n    var bits = this.bits;\n\n    for (var y = top; y < bottom; y++) {\n      var offset = y * rowSize;\n\n      for (var x = left; x < right; x++) {\n        bits[offset + Math.floor(x / 32)] |= 1 << (x & 0x1f) & 0xFFFFFFFF;\n      }\n    }\n  };\n  /**\n   * A fast method to retrieve one row of data from the matrix as a BitArray.\n   *\n   * @param y The row to retrieve\n   * @param row An optional caller-allocated BitArray, will be allocated if null or too small\n   * @return The resulting BitArray - this reference should always be used even when passing\n   *         your own row\n   */\n\n\n  BitMatrix.prototype.getRow = function (y\n  /*int*/\n  , row) {\n    if (row === null || row === undefined || row.getSize() < this.width) {\n      row = new BitArray_1.default(this.width);\n    } else {\n      row.clear();\n    }\n\n    var rowSize = this.rowSize;\n    var bits = this.bits;\n    var offset = y * rowSize;\n\n    for (var x = 0; x < rowSize; x++) {\n      row.setBulk(x * 32, bits[offset + x]);\n    }\n\n    return row;\n  };\n  /**\n   * @param y row to set\n   * @param row {@link BitArray} to copy from\n   */\n\n\n  BitMatrix.prototype.setRow = function (y\n  /*int*/\n  , row) {\n    System_1.default.arraycopy(row.getBitArray(), 0, this.bits, y * this.rowSize, this.rowSize);\n  };\n  /**\n   * Modifies this {@code BitMatrix} to represent the same but rotated 180 degrees\n   */\n\n\n  BitMatrix.prototype.rotate180 = function () {\n    var width = this.getWidth();\n    var height = this.getHeight();\n    var topRow = new BitArray_1.default(width);\n    var bottomRow = new BitArray_1.default(width);\n\n    for (var i = 0, length_1 = Math.floor((height + 1) / 2); i < length_1; i++) {\n      topRow = this.getRow(i, topRow);\n      bottomRow = this.getRow(height - 1 - i, bottomRow);\n      topRow.reverse();\n      bottomRow.reverse();\n      this.setRow(i, bottomRow);\n      this.setRow(height - 1 - i, topRow);\n    }\n  };\n  /**\n   * This is useful in detecting the enclosing rectangle of a 'pure' barcode.\n   *\n   * @return {@code left,top,width,height} enclosing rectangle of all 1 bits, or null if it is all white\n   */\n\n\n  BitMatrix.prototype.getEnclosingRectangle = function () {\n    var width = this.width;\n    var height = this.height;\n    var rowSize = this.rowSize;\n    var bits = this.bits;\n    var left = width;\n    var top = height;\n    var right = -1;\n    var bottom = -1;\n\n    for (var y = 0; y < height; y++) {\n      for (var x32 = 0; x32 < rowSize; x32++) {\n        var theBits = bits[y * rowSize + x32];\n\n        if (theBits !== 0) {\n          if (y < top) {\n            top = y;\n          }\n\n          if (y > bottom) {\n            bottom = y;\n          }\n\n          if (x32 * 32 < left) {\n            var bit = 0;\n\n            while ((theBits << 31 - bit & 0xFFFFFFFF) === 0) {\n              bit++;\n            }\n\n            if (x32 * 32 + bit < left) {\n              left = x32 * 32 + bit;\n            }\n          }\n\n          if (x32 * 32 + 31 > right) {\n            var bit = 31;\n\n            while (theBits >>> bit === 0) {\n              bit--;\n            }\n\n            if (x32 * 32 + bit > right) {\n              right = x32 * 32 + bit;\n            }\n          }\n        }\n      }\n    }\n\n    if (right < left || bottom < top) {\n      return null;\n    }\n\n    return Int32Array.from([left, top, right - left + 1, bottom - top + 1]);\n  };\n  /**\n   * This is useful in detecting a corner of a 'pure' barcode.\n   *\n   * @return {@code x,y} coordinate of top-left-most 1 bit, or null if it is all white\n   */\n\n\n  BitMatrix.prototype.getTopLeftOnBit = function () {\n    var rowSize = this.rowSize;\n    var bits = this.bits;\n    var bitsOffset = 0;\n\n    while (bitsOffset < bits.length && bits[bitsOffset] === 0) {\n      bitsOffset++;\n    }\n\n    if (bitsOffset === bits.length) {\n      return null;\n    }\n\n    var y = bitsOffset / rowSize;\n    var x = bitsOffset % rowSize * 32;\n    var theBits = bits[bitsOffset];\n    var bit = 0;\n\n    while ((theBits << 31 - bit & 0xFFFFFFFF) === 0) {\n      bit++;\n    }\n\n    x += bit;\n    return Int32Array.from([x, y]);\n  };\n\n  BitMatrix.prototype.getBottomRightOnBit = function () {\n    var rowSize = this.rowSize;\n    var bits = this.bits;\n    var bitsOffset = bits.length - 1;\n\n    while (bitsOffset >= 0 && bits[bitsOffset] === 0) {\n      bitsOffset--;\n    }\n\n    if (bitsOffset < 0) {\n      return null;\n    }\n\n    var y = Math.floor(bitsOffset / rowSize);\n    var x = Math.floor(bitsOffset % rowSize) * 32;\n    var theBits = bits[bitsOffset];\n    var bit = 31;\n\n    while (theBits >>> bit === 0) {\n      bit--;\n    }\n\n    x += bit;\n    return Int32Array.from([x, y]);\n  };\n  /**\n   * @return The width of the matrix\n   */\n\n\n  BitMatrix.prototype.getWidth = function () {\n    return this.width;\n  };\n  /**\n   * @return The height of the matrix\n   */\n\n\n  BitMatrix.prototype.getHeight = function () {\n    return this.height;\n  };\n  /**\n   * @return The row size of the matrix\n   */\n\n\n  BitMatrix.prototype.getRowSize = function () {\n    return this.rowSize;\n  };\n  /*@Override*/\n\n\n  BitMatrix.prototype.equals = function (o) {\n    if (!(o instanceof BitMatrix)) {\n      return false;\n    }\n\n    var other = o;\n    return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize && Arrays_1.default.equals(this.bits, other.bits);\n  };\n  /*@Override*/\n\n\n  BitMatrix.prototype.hashCode = function () {\n    var hash = this.width;\n    hash = 31 * hash + this.width;\n    hash = 31 * hash + this.height;\n    hash = 31 * hash + this.rowSize;\n    hash = 31 * hash + Arrays_1.default.hashCode(this.bits);\n    return hash;\n  };\n  /**\n   * @return string representation using \"X\" for set and \" \" for unset bits\n   */\n\n  /*@Override*/\n  // public toString(): string {\n  //   return toString(\": \"X, \"  \")\n  // }\n\n  /**\n   * @param setString representation of a set bit\n   * @param unsetString representation of an unset bit\n   * @return string representation of entire matrix utilizing given strings\n   */\n  // public toString(setString: string = \"X \", unsetString: string = \"  \"): string {\n  //   return this.buildToString(setString, unsetString, \"\\n\")\n  // }\n\n  /**\n   * @param setString representation of a set bit\n   * @param unsetString representation of an unset bit\n   * @param lineSeparator newline character in string representation\n   * @return string representation of entire matrix utilizing given strings and line separator\n   * @deprecated call {@link #toString(String,String)} only, which uses \\n line separator always\n   */\n  // @Deprecated\n\n\n  BitMatrix.prototype.toString = function (setString, unsetString, lineSeparator) {\n    if (setString === void 0) {\n      setString = 'X ';\n    }\n\n    if (unsetString === void 0) {\n      unsetString = '  ';\n    }\n\n    if (lineSeparator === void 0) {\n      lineSeparator = '\\n';\n    }\n\n    return this.buildToString(setString, unsetString, lineSeparator);\n  };\n\n  BitMatrix.prototype.buildToString = function (setString, unsetString, lineSeparator) {\n    var result = new StringBuilder_1.default(); // result.append(lineSeparator);\n\n    for (var y = 0, height = this.height; y < height; y++) {\n      for (var x = 0, width = this.width; x < width; x++) {\n        result.append(this.get(x, y) ? setString : unsetString);\n      }\n\n      result.append(lineSeparator);\n    }\n\n    return result.toString();\n  };\n  /*@Override*/\n\n\n  BitMatrix.prototype.clone = function () {\n    return new BitMatrix(this.width, this.height, this.rowSize, this.bits.slice());\n  };\n\n  return BitMatrix;\n}();\n\nexports.default = BitMatrix;","map":{"version":3,"sources":["../../../src/core/common/BitMatrix.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.common {*/\n/*import java.util.Arrays;*/\nvar BitArray_1 = require(\"./BitArray\");\nvar System_1 = require(\"../util/System\");\nvar Arrays_1 = require(\"../util/Arrays\");\nvar StringBuilder_1 = require(\"../util/StringBuilder\");\nvar IllegalArgumentException_1 = require(\"../IllegalArgumentException\");\n/**\n * <p>Represents a 2D matrix of bits. In function arguments below, and throughout the common\n * module, x is the column position, and y is the row position. The ordering is always x, y.\n * The origin is at the top-left.</p>\n *\n * <p>Internally the bits are represented in a 1-D array of 32-bit ints. However, each row begins\n * with a new int. This is done intentionally so that we can copy out a row into a BitArray very\n * efficiently.</p>\n *\n * <p>The ordering of bits is row-major. Within each int, the least significant bits are used first,\n * meaning they represent lower x values. This is compatible with BitArray's implementation.</p>\n *\n * @author Sean Owen\n * @author dswitkin@google.com (Daniel Switkin)\n */\nvar BitMatrix /*implements Cloneable*/ = /** @class */ (function () {\n    /**\n     * Creates an empty square {@link BitMatrix}.\n     *\n     * @param dimension height and width\n     */\n    // public constructor(dimension: number /*int*/) {\n    //   this(dimension, dimension)\n    // }\n    /**\n     * Creates an empty {@link BitMatrix}.\n     *\n     * @param width bit matrix width\n     * @param height bit matrix height\n     */\n    // public constructor(width: number /*int*/, height: number /*int*/) {\n    //   if (width < 1 || height < 1) {\n    //     throw new IllegalArgumentException(\"Both dimensions must be greater than 0\")\n    //   }\n    //   this.width = width\n    //   this.height = height\n    //   this.rowSize = (width + 31) / 32\n    //   bits = new int[rowSize * height];\n    // }\n    function BitMatrix(width /*int*/, height /*int*/, rowSize /*int*/, bits) {\n        this.width = width;\n        this.height = height;\n        this.rowSize = rowSize;\n        this.bits = bits;\n        if (undefined === height || null === height) {\n            height = width;\n        }\n        this.height = height;\n        if (width < 1 || height < 1) {\n            throw new IllegalArgumentException_1.default('Both dimensions must be greater than 0');\n        }\n        if (undefined === rowSize || null === rowSize) {\n            rowSize = Math.floor((width + 31) / 32);\n        }\n        this.rowSize = rowSize;\n        if (undefined === bits || null === bits) {\n            this.bits = new Int32Array(this.rowSize * this.height);\n        }\n    }\n    /**\n     * Interprets a 2D array of booleans as a {@link BitMatrix}, where \"true\" means an \"on\" bit.\n     *\n     * @function parse\n     * @param image bits of the image, as a row-major 2D array. Elements are arrays representing rows\n     * @return {@link BitMatrix} representation of image\n     */\n    BitMatrix.parseFromBooleanArray = function (image) {\n        var height = image.length;\n        var width = image[0].length;\n        var bits = new BitMatrix(width, height);\n        for (var i = 0; i < height; i++) {\n            var imageI = image[i];\n            for (var j = 0; j < width; j++) {\n                if (imageI[j]) {\n                    bits.set(j, i);\n                }\n            }\n        }\n        return bits;\n    };\n    /**\n     *\n     * @function parse\n     * @param stringRepresentation\n     * @param setString\n     * @param unsetString\n     */\n    BitMatrix.parseFromString = function (stringRepresentation, setString, unsetString) {\n        if (stringRepresentation === null) {\n            throw new IllegalArgumentException_1.default('stringRepresentation cannot be null');\n        }\n        var bits = new Array(stringRepresentation.length);\n        var bitsPos = 0;\n        var rowStartPos = 0;\n        var rowLength = -1;\n        var nRows = 0;\n        var pos = 0;\n        while (pos < stringRepresentation.length) {\n            if (stringRepresentation.charAt(pos) === '\\n' ||\n                stringRepresentation.charAt(pos) === '\\r') {\n                if (bitsPos > rowStartPos) {\n                    if (rowLength === -1) {\n                        rowLength = bitsPos - rowStartPos;\n                    }\n                    else if (bitsPos - rowStartPos !== rowLength) {\n                        throw new IllegalArgumentException_1.default('row lengths do not match');\n                    }\n                    rowStartPos = bitsPos;\n                    nRows++;\n                }\n                pos++;\n            }\n            else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {\n                pos += setString.length;\n                bits[bitsPos] = true;\n                bitsPos++;\n            }\n            else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {\n                pos += unsetString.length;\n                bits[bitsPos] = false;\n                bitsPos++;\n            }\n            else {\n                throw new IllegalArgumentException_1.default('illegal character encountered: ' + stringRepresentation.substring(pos));\n            }\n        }\n        // no EOL at end?\n        if (bitsPos > rowStartPos) {\n            if (rowLength === -1) {\n                rowLength = bitsPos - rowStartPos;\n            }\n            else if (bitsPos - rowStartPos !== rowLength) {\n                throw new IllegalArgumentException_1.default('row lengths do not match');\n            }\n            nRows++;\n        }\n        var matrix = new BitMatrix(rowLength, nRows);\n        for (var i = 0; i < bitsPos; i++) {\n            if (bits[i]) {\n                matrix.set(Math.floor(i % rowLength), Math.floor(i / rowLength));\n            }\n        }\n        return matrix;\n    };\n    /**\n     * <p>Gets the requested bit, where true means black.</p>\n     *\n     * @param x The horizontal component (i.e. which column)\n     * @param y The vertical component (i.e. which row)\n     * @return value of given bit in matrix\n     */\n    BitMatrix.prototype.get = function (x /*int*/, y /*int*/) {\n        var offset = y * this.rowSize + Math.floor(x / 32);\n        return ((this.bits[offset] >>> (x & 0x1f)) & 1) !== 0;\n    };\n    /**\n     * <p>Sets the given bit to true.</p>\n     *\n     * @param x The horizontal component (i.e. which column)\n     * @param y The vertical component (i.e. which row)\n     */\n    BitMatrix.prototype.set = function (x /*int*/, y /*int*/) {\n        var offset = y * this.rowSize + Math.floor(x / 32);\n        this.bits[offset] |= (1 << (x & 0x1f)) & 0xFFFFFFFF;\n    };\n    BitMatrix.prototype.unset = function (x /*int*/, y /*int*/) {\n        var offset = y * this.rowSize + Math.floor(x / 32);\n        this.bits[offset] &= ~((1 << (x & 0x1f)) & 0xFFFFFFFF);\n    };\n    /**\n     * <p>Flips the given bit.</p>\n     *\n     * @param x The horizontal component (i.e. which column)\n     * @param y The vertical component (i.e. which row)\n     */\n    BitMatrix.prototype.flip = function (x /*int*/, y /*int*/) {\n        var offset = y * this.rowSize + Math.floor(x / 32);\n        this.bits[offset] ^= ((1 << (x & 0x1f)) & 0xFFFFFFFF);\n    };\n    /**\n     * Exclusive-or (XOR): Flip the bit in this {@code BitMatrix} if the corresponding\n     * mask bit is set.\n     *\n     * @param mask XOR mask\n     */\n    BitMatrix.prototype.xor = function (mask) {\n        if (this.width !== mask.getWidth() || this.height !== mask.getHeight()\n            || this.rowSize !== mask.getRowSize()) {\n            throw new IllegalArgumentException_1.default('input matrix dimensions do not match');\n        }\n        var rowArray = new BitArray_1.default(Math.floor(this.width / 32) + 1);\n        var rowSize = this.rowSize;\n        var bits = this.bits;\n        for (var y = 0, height = this.height; y < height; y++) {\n            var offset = y * rowSize;\n            var row = mask.getRow(y, rowArray).getBitArray();\n            for (var x = 0; x < rowSize; x++) {\n                bits[offset + x] ^= row[x];\n            }\n        }\n    };\n    /**\n     * Clears all bits (sets to false).\n     */\n    BitMatrix.prototype.clear = function () {\n        var bits = this.bits;\n        var max = bits.length;\n        for (var i = 0; i < max; i++) {\n            bits[i] = 0;\n        }\n    };\n    /**\n     * <p>Sets a square region of the bit matrix to true.</p>\n     *\n     * @param left The horizontal position to begin at (inclusive)\n     * @param top The vertical position to begin at (inclusive)\n     * @param width The width of the region\n     * @param height The height of the region\n     */\n    BitMatrix.prototype.setRegion = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n        if (top < 0 || left < 0) {\n            throw new IllegalArgumentException_1.default('Left and top must be nonnegative');\n        }\n        if (height < 1 || width < 1) {\n            throw new IllegalArgumentException_1.default('Height and width must be at least 1');\n        }\n        var right = left + width;\n        var bottom = top + height;\n        if (bottom > this.height || right > this.width) {\n            throw new IllegalArgumentException_1.default('The region must fit inside the matrix');\n        }\n        var rowSize = this.rowSize;\n        var bits = this.bits;\n        for (var y = top; y < bottom; y++) {\n            var offset = y * rowSize;\n            for (var x = left; x < right; x++) {\n                bits[offset + Math.floor(x / 32)] |= ((1 << (x & 0x1f)) & 0xFFFFFFFF);\n            }\n        }\n    };\n    /**\n     * A fast method to retrieve one row of data from the matrix as a BitArray.\n     *\n     * @param y The row to retrieve\n     * @param row An optional caller-allocated BitArray, will be allocated if null or too small\n     * @return The resulting BitArray - this reference should always be used even when passing\n     *         your own row\n     */\n    BitMatrix.prototype.getRow = function (y /*int*/, row) {\n        if (row === null || row === undefined || row.getSize() < this.width) {\n            row = new BitArray_1.default(this.width);\n        }\n        else {\n            row.clear();\n        }\n        var rowSize = this.rowSize;\n        var bits = this.bits;\n        var offset = y * rowSize;\n        for (var x = 0; x < rowSize; x++) {\n            row.setBulk(x * 32, bits[offset + x]);\n        }\n        return row;\n    };\n    /**\n     * @param y row to set\n     * @param row {@link BitArray} to copy from\n     */\n    BitMatrix.prototype.setRow = function (y /*int*/, row) {\n        System_1.default.arraycopy(row.getBitArray(), 0, this.bits, y * this.rowSize, this.rowSize);\n    };\n    /**\n     * Modifies this {@code BitMatrix} to represent the same but rotated 180 degrees\n     */\n    BitMatrix.prototype.rotate180 = function () {\n        var width = this.getWidth();\n        var height = this.getHeight();\n        var topRow = new BitArray_1.default(width);\n        var bottomRow = new BitArray_1.default(width);\n        for (var i = 0, length_1 = Math.floor((height + 1) / 2); i < length_1; i++) {\n            topRow = this.getRow(i, topRow);\n            bottomRow = this.getRow(height - 1 - i, bottomRow);\n            topRow.reverse();\n            bottomRow.reverse();\n            this.setRow(i, bottomRow);\n            this.setRow(height - 1 - i, topRow);\n        }\n    };\n    /**\n     * This is useful in detecting the enclosing rectangle of a 'pure' barcode.\n     *\n     * @return {@code left,top,width,height} enclosing rectangle of all 1 bits, or null if it is all white\n     */\n    BitMatrix.prototype.getEnclosingRectangle = function () {\n        var width = this.width;\n        var height = this.height;\n        var rowSize = this.rowSize;\n        var bits = this.bits;\n        var left = width;\n        var top = height;\n        var right = -1;\n        var bottom = -1;\n        for (var y = 0; y < height; y++) {\n            for (var x32 = 0; x32 < rowSize; x32++) {\n                var theBits = bits[y * rowSize + x32];\n                if (theBits !== 0) {\n                    if (y < top) {\n                        top = y;\n                    }\n                    if (y > bottom) {\n                        bottom = y;\n                    }\n                    if (x32 * 32 < left) {\n                        var bit = 0;\n                        while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {\n                            bit++;\n                        }\n                        if ((x32 * 32 + bit) < left) {\n                            left = x32 * 32 + bit;\n                        }\n                    }\n                    if (x32 * 32 + 31 > right) {\n                        var bit = 31;\n                        while ((theBits >>> bit) === 0) {\n                            bit--;\n                        }\n                        if ((x32 * 32 + bit) > right) {\n                            right = x32 * 32 + bit;\n                        }\n                    }\n                }\n            }\n        }\n        if (right < left || bottom < top) {\n            return null;\n        }\n        return Int32Array.from([left, top, right - left + 1, bottom - top + 1]);\n    };\n    /**\n     * This is useful in detecting a corner of a 'pure' barcode.\n     *\n     * @return {@code x,y} coordinate of top-left-most 1 bit, or null if it is all white\n     */\n    BitMatrix.prototype.getTopLeftOnBit = function () {\n        var rowSize = this.rowSize;\n        var bits = this.bits;\n        var bitsOffset = 0;\n        while (bitsOffset < bits.length && bits[bitsOffset] === 0) {\n            bitsOffset++;\n        }\n        if (bitsOffset === bits.length) {\n            return null;\n        }\n        var y = bitsOffset / rowSize;\n        var x = (bitsOffset % rowSize) * 32;\n        var theBits = bits[bitsOffset];\n        var bit = 0;\n        while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {\n            bit++;\n        }\n        x += bit;\n        return Int32Array.from([x, y]);\n    };\n    BitMatrix.prototype.getBottomRightOnBit = function () {\n        var rowSize = this.rowSize;\n        var bits = this.bits;\n        var bitsOffset = bits.length - 1;\n        while (bitsOffset >= 0 && bits[bitsOffset] === 0) {\n            bitsOffset--;\n        }\n        if (bitsOffset < 0) {\n            return null;\n        }\n        var y = Math.floor(bitsOffset / rowSize);\n        var x = Math.floor(bitsOffset % rowSize) * 32;\n        var theBits = bits[bitsOffset];\n        var bit = 31;\n        while ((theBits >>> bit) === 0) {\n            bit--;\n        }\n        x += bit;\n        return Int32Array.from([x, y]);\n    };\n    /**\n     * @return The width of the matrix\n     */\n    BitMatrix.prototype.getWidth = function () {\n        return this.width;\n    };\n    /**\n     * @return The height of the matrix\n     */\n    BitMatrix.prototype.getHeight = function () {\n        return this.height;\n    };\n    /**\n     * @return The row size of the matrix\n     */\n    BitMatrix.prototype.getRowSize = function () {\n        return this.rowSize;\n    };\n    /*@Override*/\n    BitMatrix.prototype.equals = function (o) {\n        if (!(o instanceof BitMatrix)) {\n            return false;\n        }\n        var other = o;\n        return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize &&\n            Arrays_1.default.equals(this.bits, other.bits);\n    };\n    /*@Override*/\n    BitMatrix.prototype.hashCode = function () {\n        var hash = this.width;\n        hash = 31 * hash + this.width;\n        hash = 31 * hash + this.height;\n        hash = 31 * hash + this.rowSize;\n        hash = 31 * hash + Arrays_1.default.hashCode(this.bits);\n        return hash;\n    };\n    /**\n     * @return string representation using \"X\" for set and \" \" for unset bits\n     */\n    /*@Override*/\n    // public toString(): string {\n    //   return toString(\": \"X, \"  \")\n    // }\n    /**\n     * @param setString representation of a set bit\n     * @param unsetString representation of an unset bit\n     * @return string representation of entire matrix utilizing given strings\n     */\n    // public toString(setString: string = \"X \", unsetString: string = \"  \"): string {\n    //   return this.buildToString(setString, unsetString, \"\\n\")\n    // }\n    /**\n     * @param setString representation of a set bit\n     * @param unsetString representation of an unset bit\n     * @param lineSeparator newline character in string representation\n     * @return string representation of entire matrix utilizing given strings and line separator\n     * @deprecated call {@link #toString(String,String)} only, which uses \\n line separator always\n     */\n    // @Deprecated\n    BitMatrix.prototype.toString = function (setString, unsetString, lineSeparator) {\n        if (setString === void 0) { setString = 'X '; }\n        if (unsetString === void 0) { unsetString = '  '; }\n        if (lineSeparator === void 0) { lineSeparator = '\\n'; }\n        return this.buildToString(setString, unsetString, lineSeparator);\n    };\n    BitMatrix.prototype.buildToString = function (setString, unsetString, lineSeparator) {\n        var result = new StringBuilder_1.default();\n        // result.append(lineSeparator);\n        for (var y = 0, height = this.height; y < height; y++) {\n            for (var x = 0, width = this.width; x < width; x++) {\n                result.append(this.get(x, y) ? setString : unsetString);\n            }\n            result.append(lineSeparator);\n        }\n        return result.toString();\n    };\n    /*@Override*/\n    BitMatrix.prototype.clone = function () {\n        return new BitMatrix(this.width, this.height, this.rowSize, this.bits.slice());\n    };\n    return BitMatrix;\n}());\nexports.default = BitMatrix;\n//# sourceMappingURL=BitMatrix.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Version_1 = require(\"./Version\");\n\nvar FormatInformation_1 = require(\"./FormatInformation\");\n\nvar DataMask_1 = require(\"./DataMask\");\n\nvar FormatException_1 = require(\"../../FormatException\");\n/**\n * @author Sean Owen\n */\n\n\nvar BitMatrixParser =\n/** @class */\nfunction () {\n  /**\n   * @param bitMatrix {@link BitMatrix} to parse\n   * @throws FormatException if dimension is not >= 21 and 1 mod 4\n   */\n  function BitMatrixParser(bitMatrix) {\n    var dimension = bitMatrix.getHeight();\n\n    if (dimension < 21 || (dimension & 0x03) !== 1) {\n      throw new FormatException_1.default();\n    }\n\n    this.bitMatrix = bitMatrix;\n  }\n  /**\n   * <p>Reads format information from one of its two locations within the QR Code.</p>\n   *\n   * @return {@link FormatInformation} encapsulating the QR Code's format info\n   * @throws FormatException if both format information locations cannot be parsed as\n   * the valid encoding of format information\n   */\n\n\n  BitMatrixParser.prototype.readFormatInformation = function () {\n    if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== undefined) {\n      return this.parsedFormatInfo;\n    } // Read top-left format info bits\n\n\n    var formatInfoBits1 = 0;\n\n    for (var i = 0; i < 6; i++) {\n      formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);\n    } // .. and skip a bit in the timing pattern ...\n\n\n    formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);\n    formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);\n    formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1); // .. and skip a bit in the timing pattern ...\n\n    for (var j = 5; j >= 0; j--) {\n      formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);\n    } // Read the top-right/bottom-left pattern too\n\n\n    var dimension = this.bitMatrix.getHeight();\n    var formatInfoBits2 = 0;\n    var jMin = dimension - 7;\n\n    for (var j = dimension - 1; j >= jMin; j--) {\n      formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);\n    }\n\n    for (var i = dimension - 8; i < dimension; i++) {\n      formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);\n    }\n\n    this.parsedFormatInfo = FormatInformation_1.default.decodeFormatInformation(formatInfoBits1, formatInfoBits2);\n\n    if (this.parsedFormatInfo !== null) {\n      return this.parsedFormatInfo;\n    }\n\n    throw new FormatException_1.default();\n  };\n  /**\n   * <p>Reads version information from one of its two locations within the QR Code.</p>\n   *\n   * @return {@link Version} encapsulating the QR Code's version\n   * @throws FormatException if both version information locations cannot be parsed as\n   * the valid encoding of version information\n   */\n\n\n  BitMatrixParser.prototype.readVersion = function () {\n    if (this.parsedVersion !== null && this.parsedVersion !== undefined) {\n      return this.parsedVersion;\n    }\n\n    var dimension = this.bitMatrix.getHeight();\n    var provisionalVersion = Math.floor((dimension - 17) / 4);\n\n    if (provisionalVersion <= 6) {\n      return Version_1.default.getVersionForNumber(provisionalVersion);\n    } // Read top-right version info: 3 wide by 6 tall\n\n\n    var versionBits = 0;\n    var ijMin = dimension - 11;\n\n    for (var j = 5; j >= 0; j--) {\n      for (var i = dimension - 9; i >= ijMin; i--) {\n        versionBits = this.copyBit(i, j, versionBits);\n      }\n    }\n\n    var theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);\n\n    if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n      this.parsedVersion = theParsedVersion;\n      return theParsedVersion;\n    } // Hmm, failed. Try bottom left: 6 wide by 3 tall\n\n\n    versionBits = 0;\n\n    for (var i = 5; i >= 0; i--) {\n      for (var j = dimension - 9; j >= ijMin; j--) {\n        versionBits = this.copyBit(i, j, versionBits);\n      }\n    }\n\n    theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);\n\n    if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n      this.parsedVersion = theParsedVersion;\n      return theParsedVersion;\n    }\n\n    throw new FormatException_1.default();\n  };\n\n  BitMatrixParser.prototype.copyBit = function (i\n  /*int*/\n  , j\n  /*int*/\n  , versionBits\n  /*int*/\n  ) {\n    var bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);\n    return bit ? versionBits << 1 | 0x1 : versionBits << 1;\n  };\n  /**\n   * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the\n   * correct order in order to reconstruct the codewords bytes contained within the\n   * QR Code.</p>\n   *\n   * @return bytes encoded within the QR Code\n   * @throws FormatException if the exact number of bytes expected is not read\n   */\n\n\n  BitMatrixParser.prototype.readCodewords = function () {\n    var formatInfo = this.readFormatInformation();\n    var version = this.readVersion(); // Get the data mask for the format used in this QR Code. This will exclude\n    // some bits from reading as we wind through the bit matrix.\n\n    var dataMask = DataMask_1.default.values.get(formatInfo.getDataMask());\n    var dimension = this.bitMatrix.getHeight();\n    dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n    var functionPattern = version.buildFunctionPattern();\n    var readingUp = true;\n    var result = new Uint8Array(version.getTotalCodewords());\n    var resultOffset = 0;\n    var currentByte = 0;\n    var bitsRead = 0; // Read columns in pairs, from right to left\n\n    for (var j = dimension - 1; j > 0; j -= 2) {\n      if (j === 6) {\n        // Skip whole column with vertical alignment pattern\n        // saves time and makes the other code proceed more cleanly\n        j--;\n      } // Read alternatingly from bottom to top then top to bottom\n\n\n      for (var count = 0; count < dimension; count++) {\n        var i = readingUp ? dimension - 1 - count : count;\n\n        for (var col = 0; col < 2; col++) {\n          // Ignore bits covered by the function pattern\n          if (!functionPattern.get(j - col, i)) {\n            // Read a bit\n            bitsRead++;\n            currentByte <<= 1;\n\n            if (this.bitMatrix.get(j - col, i)) {\n              currentByte |= 1;\n            } // If we've made a whole byte, save it off\n\n\n            if (bitsRead === 8) {\n              result[resultOffset++] =\n              /*(byte) */\n              currentByte;\n              bitsRead = 0;\n              currentByte = 0;\n            }\n          }\n        }\n      }\n\n      readingUp = !readingUp; // readingUp ^= true; // readingUp = !readingUp; // switch directions\n    }\n\n    if (resultOffset !== version.getTotalCodewords()) {\n      throw new FormatException_1.default();\n    }\n\n    return result;\n  };\n  /**\n   * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.\n   */\n\n\n  BitMatrixParser.prototype.remask = function () {\n    if (this.parsedFormatInfo === null) {\n      return; // We have no format information, and have no data mask\n    }\n\n    var dataMask = DataMask_1.default.values[this.parsedFormatInfo.getDataMask()];\n    var dimension = this.bitMatrix.getHeight();\n    dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n  };\n  /**\n   * Prepare the parser for a mirrored operation.\n   * This flag has effect only on the {@link #readFormatInformation()} and the\n   * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the\n   * {@link #mirror()} method should be called.\n   *\n   * @param mirror Whether to read version and format information mirrored.\n   */\n\n\n  BitMatrixParser.prototype.setMirror = function (isMirror) {\n    this.parsedVersion = null;\n    this.parsedFormatInfo = null;\n    this.isMirror = isMirror;\n  };\n  /** Mirror the bit matrix in order to attempt a second reading. */\n\n\n  BitMatrixParser.prototype.mirror = function () {\n    var bitMatrix = this.bitMatrix;\n\n    for (var x = 0, width = bitMatrix.getWidth(); x < width; x++) {\n      for (var y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {\n        if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {\n          bitMatrix.flip(y, x);\n          bitMatrix.flip(x, y);\n        }\n      }\n    }\n  };\n\n  return BitMatrixParser;\n}();\n\nexports.default = BitMatrixParser;","map":{"version":3,"sources":["../../../../src/core/qrcode/decoder/BitMatrixParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Version_1 = require(\"./Version\");\nvar FormatInformation_1 = require(\"./FormatInformation\");\nvar DataMask_1 = require(\"./DataMask\");\nvar FormatException_1 = require(\"../../FormatException\");\n/**\n * @author Sean Owen\n */\nvar BitMatrixParser = /** @class */ (function () {\n    /**\n     * @param bitMatrix {@link BitMatrix} to parse\n     * @throws FormatException if dimension is not >= 21 and 1 mod 4\n     */\n    function BitMatrixParser(bitMatrix) {\n        var dimension = bitMatrix.getHeight();\n        if (dimension < 21 || (dimension & 0x03) !== 1) {\n            throw new FormatException_1.default();\n        }\n        this.bitMatrix = bitMatrix;\n    }\n    /**\n     * <p>Reads format information from one of its two locations within the QR Code.</p>\n     *\n     * @return {@link FormatInformation} encapsulating the QR Code's format info\n     * @throws FormatException if both format information locations cannot be parsed as\n     * the valid encoding of format information\n     */\n    BitMatrixParser.prototype.readFormatInformation = function () {\n        if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== undefined) {\n            return this.parsedFormatInfo;\n        }\n        // Read top-left format info bits\n        var formatInfoBits1 = 0;\n        for (var i = 0; i < 6; i++) {\n            formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);\n        }\n        // .. and skip a bit in the timing pattern ...\n        formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);\n        formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);\n        formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);\n        // .. and skip a bit in the timing pattern ...\n        for (var j = 5; j >= 0; j--) {\n            formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);\n        }\n        // Read the top-right/bottom-left pattern too\n        var dimension = this.bitMatrix.getHeight();\n        var formatInfoBits2 = 0;\n        var jMin = dimension - 7;\n        for (var j = dimension - 1; j >= jMin; j--) {\n            formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);\n        }\n        for (var i = dimension - 8; i < dimension; i++) {\n            formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);\n        }\n        this.parsedFormatInfo = FormatInformation_1.default.decodeFormatInformation(formatInfoBits1, formatInfoBits2);\n        if (this.parsedFormatInfo !== null) {\n            return this.parsedFormatInfo;\n        }\n        throw new FormatException_1.default();\n    };\n    /**\n     * <p>Reads version information from one of its two locations within the QR Code.</p>\n     *\n     * @return {@link Version} encapsulating the QR Code's version\n     * @throws FormatException if both version information locations cannot be parsed as\n     * the valid encoding of version information\n     */\n    BitMatrixParser.prototype.readVersion = function () {\n        if (this.parsedVersion !== null && this.parsedVersion !== undefined) {\n            return this.parsedVersion;\n        }\n        var dimension = this.bitMatrix.getHeight();\n        var provisionalVersion = Math.floor((dimension - 17) / 4);\n        if (provisionalVersion <= 6) {\n            return Version_1.default.getVersionForNumber(provisionalVersion);\n        }\n        // Read top-right version info: 3 wide by 6 tall\n        var versionBits = 0;\n        var ijMin = dimension - 11;\n        for (var j = 5; j >= 0; j--) {\n            for (var i = dimension - 9; i >= ijMin; i--) {\n                versionBits = this.copyBit(i, j, versionBits);\n            }\n        }\n        var theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);\n        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n            this.parsedVersion = theParsedVersion;\n            return theParsedVersion;\n        }\n        // Hmm, failed. Try bottom left: 6 wide by 3 tall\n        versionBits = 0;\n        for (var i = 5; i >= 0; i--) {\n            for (var j = dimension - 9; j >= ijMin; j--) {\n                versionBits = this.copyBit(i, j, versionBits);\n            }\n        }\n        theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);\n        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n            this.parsedVersion = theParsedVersion;\n            return theParsedVersion;\n        }\n        throw new FormatException_1.default();\n    };\n    BitMatrixParser.prototype.copyBit = function (i /*int*/, j /*int*/, versionBits /*int*/) {\n        var bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);\n        return bit ? (versionBits << 1) | 0x1 : versionBits << 1;\n    };\n    /**\n     * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the\n     * correct order in order to reconstruct the codewords bytes contained within the\n     * QR Code.</p>\n     *\n     * @return bytes encoded within the QR Code\n     * @throws FormatException if the exact number of bytes expected is not read\n     */\n    BitMatrixParser.prototype.readCodewords = function () {\n        var formatInfo = this.readFormatInformation();\n        var version = this.readVersion();\n        // Get the data mask for the format used in this QR Code. This will exclude\n        // some bits from reading as we wind through the bit matrix.\n        var dataMask = DataMask_1.default.values.get(formatInfo.getDataMask());\n        var dimension = this.bitMatrix.getHeight();\n        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n        var functionPattern = version.buildFunctionPattern();\n        var readingUp = true;\n        var result = new Uint8Array(version.getTotalCodewords());\n        var resultOffset = 0;\n        var currentByte = 0;\n        var bitsRead = 0;\n        // Read columns in pairs, from right to left\n        for (var j = dimension - 1; j > 0; j -= 2) {\n            if (j === 6) {\n                // Skip whole column with vertical alignment pattern\n                // saves time and makes the other code proceed more cleanly\n                j--;\n            }\n            // Read alternatingly from bottom to top then top to bottom\n            for (var count = 0; count < dimension; count++) {\n                var i = readingUp ? dimension - 1 - count : count;\n                for (var col = 0; col < 2; col++) {\n                    // Ignore bits covered by the function pattern\n                    if (!functionPattern.get(j - col, i)) {\n                        // Read a bit\n                        bitsRead++;\n                        currentByte <<= 1;\n                        if (this.bitMatrix.get(j - col, i)) {\n                            currentByte |= 1;\n                        }\n                        // If we've made a whole byte, save it off\n                        if (bitsRead === 8) {\n                            result[resultOffset++] = /*(byte) */ currentByte;\n                            bitsRead = 0;\n                            currentByte = 0;\n                        }\n                    }\n                }\n            }\n            readingUp = !readingUp; // readingUp ^= true; // readingUp = !readingUp; // switch directions\n        }\n        if (resultOffset !== version.getTotalCodewords()) {\n            throw new FormatException_1.default();\n        }\n        return result;\n    };\n    /**\n     * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.\n     */\n    BitMatrixParser.prototype.remask = function () {\n        if (this.parsedFormatInfo === null) {\n            return; // We have no format information, and have no data mask\n        }\n        var dataMask = DataMask_1.default.values[this.parsedFormatInfo.getDataMask()];\n        var dimension = this.bitMatrix.getHeight();\n        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n    };\n    /**\n     * Prepare the parser for a mirrored operation.\n     * This flag has effect only on the {@link #readFormatInformation()} and the\n     * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the\n     * {@link #mirror()} method should be called.\n     *\n     * @param mirror Whether to read version and format information mirrored.\n     */\n    BitMatrixParser.prototype.setMirror = function (isMirror) {\n        this.parsedVersion = null;\n        this.parsedFormatInfo = null;\n        this.isMirror = isMirror;\n    };\n    /** Mirror the bit matrix in order to attempt a second reading. */\n    BitMatrixParser.prototype.mirror = function () {\n        var bitMatrix = this.bitMatrix;\n        for (var x = 0, width = bitMatrix.getWidth(); x < width; x++) {\n            for (var y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {\n                if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {\n                    bitMatrix.flip(y, x);\n                    bitMatrix.flip(x, y);\n                }\n            }\n        }\n    };\n    return BitMatrixParser;\n}());\nexports.default = BitMatrixParser;\n//# sourceMappingURL=BitMatrixParser.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\n\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\n\nvar Result_1 = require(\"../Result\");\n\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\n\nvar ResultPoint_1 = require(\"../ResultPoint\");\n\nvar UPCEANExtensionSupport_1 = require(\"./UPCEANExtensionSupport\");\n\nvar AbstractUPCEANReader_1 = require(\"./AbstractUPCEANReader\");\n\nvar NotFoundException_1 = require(\"../NotFoundException\");\n\nvar FormatException_1 = require(\"../FormatException\");\n\nvar ChecksumException_1 = require(\"../ChecksumException\");\n/**\n * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\n * of one-dimensional barcodes.</p>\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n * @author alasdair@google.com (Alasdair Mackintosh)\n */\n\n\nvar UPCEANReader =\n/** @class */\nfunction (_super) {\n  __extends(UPCEANReader, _super);\n\n  function UPCEANReader() {\n    var _this = _super.call(this) || this;\n\n    _this.decodeRowStringBuffer = '';\n    UPCEANReader.L_AND_G_PATTERNS = UPCEANReader.L_PATTERNS.map(function (arr) {\n      return arr.slice();\n    });\n\n    for (var i = 10; i < 20; i++) {\n      var widths = UPCEANReader.L_PATTERNS[i - 10];\n      var reversedWidths = new Array(widths.length);\n\n      for (var j = 0; j < widths.length; j++) {\n        reversedWidths[j] = widths[widths.length - j - 1];\n      }\n\n      UPCEANReader.L_AND_G_PATTERNS[i] = reversedWidths;\n    }\n\n    return _this;\n  }\n\n  UPCEANReader.prototype.decodeRow = function (rowNumber, row, hints) {\n    var startGuardRange = UPCEANReader.findStartGuardPattern(row);\n    var resultPointCallback = hints == null ? null : hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n\n    if (resultPointCallback != null) {\n      var resultPoint_1 = new ResultPoint_1.default((startGuardRange[0] + startGuardRange[1]) / 2.0, rowNumber);\n      resultPointCallback.foundPossibleResultPoint(resultPoint_1);\n    }\n\n    var budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);\n    var endStart = budello.rowOffset;\n    var result = budello.resultString;\n\n    if (resultPointCallback != null) {\n      var resultPoint_2 = new ResultPoint_1.default(endStart, rowNumber);\n      resultPointCallback.foundPossibleResultPoint(resultPoint_2);\n    }\n\n    var endRange = UPCEANReader.decodeEnd(row, endStart);\n\n    if (resultPointCallback != null) {\n      var resultPoint_3 = new ResultPoint_1.default((endRange[0] + endRange[1]) / 2.0, rowNumber);\n      resultPointCallback.foundPossibleResultPoint(resultPoint_3);\n    } // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The\n    // spec might want more whitespace, but in practice this is the maximum we can count on.\n\n\n    var end = endRange[1];\n    var quietEnd = end + (end - endRange[0]);\n\n    if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {\n      throw new NotFoundException_1.default();\n    }\n\n    var resultString = result.toString(); // UPC/EAN should never be less than 8 chars anyway\n\n    if (resultString.length < 8) {\n      throw new FormatException_1.default();\n    }\n\n    if (!UPCEANReader.checkChecksum(resultString)) {\n      throw new ChecksumException_1.default();\n    }\n\n    var left = (startGuardRange[1] + startGuardRange[0]) / 2.0;\n    var right = (endRange[1] + endRange[0]) / 2.0;\n    var format = this.getBarcodeFormat();\n    var resultPoint = [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)];\n    var decodeResult = new Result_1.default(resultString, null, 0, resultPoint, format, new Date().getTime());\n    var extensionLength = 0;\n\n    try {\n      var extensionResult = UPCEANExtensionSupport_1.default.decodeRow(rowNumber, row, endRange[1]);\n      decodeResult.putMetadata(ResultMetadataType_1.default.UPC_EAN_EXTENSION, extensionResult.getText());\n      decodeResult.putAllMetadata(extensionResult.getResultMetadata());\n      decodeResult.addResultPoints(extensionResult.getResultPoints());\n      extensionLength = extensionResult.getText().length;\n    } catch (err) {}\n\n    var allowedExtensions = hints == null ? null : hints.get(DecodeHintType_1.default.ALLOWED_EAN_EXTENSIONS);\n\n    if (allowedExtensions != null) {\n      var valid = false;\n\n      for (var length_1 in allowedExtensions) {\n        if (extensionLength.toString() === length_1) {\n          // check me\n          valid = true;\n          break;\n        }\n      }\n\n      if (!valid) {\n        throw new NotFoundException_1.default();\n      }\n    }\n\n    if (format === BarcodeFormat_1.default.EAN_13 || format === BarcodeFormat_1.default.UPC_A) {// let countryID = eanManSupport.lookupContryIdentifier(resultString); todo\n      // if (countryID != null) {\n      //     decodeResult.putMetadata(ResultMetadataType.POSSIBLE_COUNTRY, countryID);\n      // }\n    }\n\n    return decodeResult;\n  };\n\n  UPCEANReader.checkChecksum = function (s) {\n    return UPCEANReader.checkStandardUPCEANChecksum(s);\n  };\n\n  UPCEANReader.checkStandardUPCEANChecksum = function (s) {\n    var length = s.length;\n    if (length === 0) return false;\n    var check = parseInt(s.charAt(length - 1), 10);\n    return UPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n  };\n\n  UPCEANReader.getStandardUPCEANChecksum = function (s) {\n    var length = s.length;\n    var sum = 0;\n\n    for (var i = length - 1; i >= 0; i -= 2) {\n      var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n\n      if (digit < 0 || digit > 9) {\n        throw new FormatException_1.default();\n      }\n\n      sum += digit;\n    }\n\n    sum *= 3;\n\n    for (var i = length - 2; i >= 0; i -= 2) {\n      var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n\n      if (digit < 0 || digit > 9) {\n        throw new FormatException_1.default();\n      }\n\n      sum += digit;\n    }\n\n    return (1000 - sum) % 10;\n  };\n\n  UPCEANReader.decodeEnd = function (row, endStart) {\n    return UPCEANReader.findGuardPattern(row, endStart, false, UPCEANReader.START_END_PATTERN, new Array(UPCEANReader.START_END_PATTERN.length).fill(0));\n  };\n\n  return UPCEANReader;\n}(AbstractUPCEANReader_1.default);\n\nexports.default = UPCEANReader;","map":{"version":3,"sources":["../../../src/core/oned/UPCEANReader.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\nvar Result_1 = require(\"../Result\");\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\nvar ResultPoint_1 = require(\"../ResultPoint\");\nvar UPCEANExtensionSupport_1 = require(\"./UPCEANExtensionSupport\");\nvar AbstractUPCEANReader_1 = require(\"./AbstractUPCEANReader\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\nvar FormatException_1 = require(\"../FormatException\");\nvar ChecksumException_1 = require(\"../ChecksumException\");\n/**\n * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\n * of one-dimensional barcodes.</p>\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n * @author alasdair@google.com (Alasdair Mackintosh)\n */\nvar UPCEANReader = /** @class */ (function (_super) {\n    __extends(UPCEANReader, _super);\n    function UPCEANReader() {\n        var _this = _super.call(this) || this;\n        _this.decodeRowStringBuffer = '';\n        UPCEANReader.L_AND_G_PATTERNS = UPCEANReader.L_PATTERNS.map(function (arr) {\n            return arr.slice();\n        });\n        for (var i = 10; i < 20; i++) {\n            var widths = UPCEANReader.L_PATTERNS[i - 10];\n            var reversedWidths = new Array(widths.length);\n            for (var j = 0; j < widths.length; j++) {\n                reversedWidths[j] = widths[widths.length - j - 1];\n            }\n            UPCEANReader.L_AND_G_PATTERNS[i] = reversedWidths;\n        }\n        return _this;\n    }\n    UPCEANReader.prototype.decodeRow = function (rowNumber, row, hints) {\n        var startGuardRange = UPCEANReader.findStartGuardPattern(row);\n        var resultPointCallback = hints == null ? null : hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n        if (resultPointCallback != null) {\n            var resultPoint_1 = new ResultPoint_1.default((startGuardRange[0] + startGuardRange[1]) / 2.0, rowNumber);\n            resultPointCallback.foundPossibleResultPoint(resultPoint_1);\n        }\n        var budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);\n        var endStart = budello.rowOffset;\n        var result = budello.resultString;\n        if (resultPointCallback != null) {\n            var resultPoint_2 = new ResultPoint_1.default(endStart, rowNumber);\n            resultPointCallback.foundPossibleResultPoint(resultPoint_2);\n        }\n        var endRange = UPCEANReader.decodeEnd(row, endStart);\n        if (resultPointCallback != null) {\n            var resultPoint_3 = new ResultPoint_1.default((endRange[0] + endRange[1]) / 2.0, rowNumber);\n            resultPointCallback.foundPossibleResultPoint(resultPoint_3);\n        }\n        // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The\n        // spec might want more whitespace, but in practice this is the maximum we can count on.\n        var end = endRange[1];\n        var quietEnd = end + (end - endRange[0]);\n        if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {\n            throw new NotFoundException_1.default();\n        }\n        var resultString = result.toString();\n        // UPC/EAN should never be less than 8 chars anyway\n        if (resultString.length < 8) {\n            throw new FormatException_1.default();\n        }\n        if (!UPCEANReader.checkChecksum(resultString)) {\n            throw new ChecksumException_1.default();\n        }\n        var left = (startGuardRange[1] + startGuardRange[0]) / 2.0;\n        var right = (endRange[1] + endRange[0]) / 2.0;\n        var format = this.getBarcodeFormat();\n        var resultPoint = [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)];\n        var decodeResult = new Result_1.default(resultString, null, 0, resultPoint, format, new Date().getTime());\n        var extensionLength = 0;\n        try {\n            var extensionResult = UPCEANExtensionSupport_1.default.decodeRow(rowNumber, row, endRange[1]);\n            decodeResult.putMetadata(ResultMetadataType_1.default.UPC_EAN_EXTENSION, extensionResult.getText());\n            decodeResult.putAllMetadata(extensionResult.getResultMetadata());\n            decodeResult.addResultPoints(extensionResult.getResultPoints());\n            extensionLength = extensionResult.getText().length;\n        }\n        catch (err) {\n        }\n        var allowedExtensions = hints == null ? null : hints.get(DecodeHintType_1.default.ALLOWED_EAN_EXTENSIONS);\n        if (allowedExtensions != null) {\n            var valid = false;\n            for (var length_1 in allowedExtensions) {\n                if (extensionLength.toString() === length_1) { // check me\n                    valid = true;\n                    break;\n                }\n            }\n            if (!valid) {\n                throw new NotFoundException_1.default();\n            }\n        }\n        if (format === BarcodeFormat_1.default.EAN_13 || format === BarcodeFormat_1.default.UPC_A) {\n            // let countryID = eanManSupport.lookupContryIdentifier(resultString); todo\n            // if (countryID != null) {\n            //     decodeResult.putMetadata(ResultMetadataType.POSSIBLE_COUNTRY, countryID);\n            // }\n        }\n        return decodeResult;\n    };\n    UPCEANReader.checkChecksum = function (s) {\n        return UPCEANReader.checkStandardUPCEANChecksum(s);\n    };\n    UPCEANReader.checkStandardUPCEANChecksum = function (s) {\n        var length = s.length;\n        if (length === 0)\n            return false;\n        var check = parseInt(s.charAt(length - 1), 10);\n        return UPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n    };\n    UPCEANReader.getStandardUPCEANChecksum = function (s) {\n        var length = s.length;\n        var sum = 0;\n        for (var i = length - 1; i >= 0; i -= 2) {\n            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            if (digit < 0 || digit > 9) {\n                throw new FormatException_1.default();\n            }\n            sum += digit;\n        }\n        sum *= 3;\n        for (var i = length - 2; i >= 0; i -= 2) {\n            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            if (digit < 0 || digit > 9) {\n                throw new FormatException_1.default();\n            }\n            sum += digit;\n        }\n        return (1000 - sum) % 10;\n    };\n    UPCEANReader.decodeEnd = function (row, endStart) {\n        return UPCEANReader.findGuardPattern(row, endStart, false, UPCEANReader.START_END_PATTERN, new Array(UPCEANReader.START_END_PATTERN.length).fill(0));\n    };\n    return UPCEANReader;\n}(AbstractUPCEANReader_1.default));\nexports.default = UPCEANReader;\n//# sourceMappingURL=UPCEANReader.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.qrcode.detector {*/\n\nvar DecodeHintType_1 = require(\"../../DecodeHintType\");\n\nvar ResultPoint_1 = require(\"../../ResultPoint\");\n\nvar DetectorResult_1 = require(\"../../common/DetectorResult\");\n\nvar GridSamplerInstance_1 = require(\"../../common/GridSamplerInstance\");\n\nvar PerspectiveTransform_1 = require(\"../../common/PerspectiveTransform\");\n\nvar MathUtils_1 = require(\"../../common/detector/MathUtils\");\n\nvar Version_1 = require(\"../decoder/Version\");\n\nvar FinderPatternFinder_1 = require(\"./FinderPatternFinder\");\n\nvar AlignmentPatternFinder_1 = require(\"./AlignmentPatternFinder\");\n\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/*import java.util.Map;*/\n\n/**\n * <p>Encapsulates logic that can detect a QR Code in an image, even if the QR Code\n * is rotated or skewed, or partially obscured.</p>\n *\n * @author Sean Owen\n */\n\n\nvar Detector =\n/** @class */\nfunction () {\n  function Detector(image) {\n    this.image = image;\n  }\n\n  Detector.prototype.getImage = function () {\n    return this.image;\n  };\n\n  Detector.prototype.getResultPointCallback = function () {\n    return this.resultPointCallback;\n  };\n  /**\n   * <p>Detects a QR Code in an image.</p>\n   *\n   * @return {@link DetectorResult} encapsulating results of detecting a QR Code\n   * @throws NotFoundException if QR Code cannot be found\n   * @throws FormatException if a QR Code cannot be decoded\n   */\n  // public detect(): DetectorResult /*throws NotFoundException, FormatException*/ {\n  //   return detect(null)\n  // }\n\n  /**\n   * <p>Detects a QR Code in an image.</p>\n   *\n   * @param hints optional hints to detector\n   * @return {@link DetectorResult} encapsulating results of detecting a QR Code\n   * @throws NotFoundException if QR Code cannot be found\n   * @throws FormatException if a QR Code cannot be decoded\n   */\n\n\n  Detector.prototype.detect = function (hints) {\n    this.resultPointCallback = hints === null || hints === undefined ? null :\n    /*(ResultPointCallback) */\n    hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n    var finder = new FinderPatternFinder_1.default(this.image, this.resultPointCallback);\n    var info = finder.find(hints);\n    return this.processFinderPatternInfo(info);\n  };\n\n  Detector.prototype.processFinderPatternInfo = function (info) {\n    var topLeft = info.getTopLeft();\n    var topRight = info.getTopRight();\n    var bottomLeft = info.getBottomLeft();\n    var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);\n\n    if (moduleSize < 1.0) {\n      throw new NotFoundException_1.default('No pattern found in proccess finder.');\n    }\n\n    var dimension = Detector.computeDimension(topLeft, topRight, bottomLeft, moduleSize);\n    var provisionalVersion = Version_1.default.getProvisionalVersionForDimension(dimension);\n    var modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;\n    var alignmentPattern = null; // Anything above version 1 has an alignment pattern\n\n    if (provisionalVersion.getAlignmentPatternCenters().length > 0) {\n      // Guess where a \"bottom right\" finder pattern would have been\n      var bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();\n      var bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY(); // Estimate that alignment pattern is closer by 3 modules\n      // from \"bottom right\" to known top left location\n\n      var correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;\n      var estAlignmentX =\n      /*(int) */\n      Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));\n      var estAlignmentY =\n      /*(int) */\n      Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY())); // Kind of arbitrary -- expand search radius before giving up\n\n      for (var i = 4; i <= 16; i <<= 1) {\n        try {\n          alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);\n          break;\n        } catch (re\n        /*NotFoundException*/\n        ) {\n          if (!(re instanceof NotFoundException_1.default)) {\n            throw re;\n          } // try next round\n\n        }\n      } // If we didn't find alignment pattern... well try anyway without it\n\n    }\n\n    var transform = Detector.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);\n    var bits = Detector.sampleGrid(this.image, transform, dimension);\n    var points;\n\n    if (alignmentPattern === null) {\n      points = [bottomLeft, topLeft, topRight];\n    } else {\n      points = [bottomLeft, topLeft, topRight, alignmentPattern];\n    }\n\n    return new DetectorResult_1.default(bits, points);\n  };\n\n  Detector.createTransform = function (topLeft, topRight, bottomLeft, alignmentPattern, dimension\n  /*int*/\n  ) {\n    var dimMinusThree = dimension - 3.5;\n    var bottomRightX;\n    /*float*/\n\n    var bottomRightY;\n    /*float*/\n\n    var sourceBottomRightX;\n    /*float*/\n\n    var sourceBottomRightY;\n    /*float*/\n\n    if (alignmentPattern !== null) {\n      bottomRightX = alignmentPattern.getX();\n      bottomRightY = alignmentPattern.getY();\n      sourceBottomRightX = dimMinusThree - 3.0;\n      sourceBottomRightY = sourceBottomRightX;\n    } else {\n      // Don't have an alignment pattern, just make up the bottom-right point\n      bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();\n      bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();\n      sourceBottomRightX = dimMinusThree;\n      sourceBottomRightY = dimMinusThree;\n    }\n\n    return PerspectiveTransform_1.default.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());\n  };\n\n  Detector.sampleGrid = function (image, transform, dimension\n  /*int*/\n  ) {\n    var sampler = GridSamplerInstance_1.default.getInstance();\n    return sampler.sampleGridWithTransform(image, dimension, dimension, transform);\n  };\n  /**\n   * <p>Computes the dimension (number of modules on a size) of the QR Code based on the position\n   * of the finder patterns and estimated module size.</p>\n   */\n\n\n  Detector.computeDimension = function (topLeft, topRight, bottomLeft, moduleSize\n  /*float*/\n  ) {\n    var tltrCentersDimension = MathUtils_1.default.round(ResultPoint_1.default.distance(topLeft, topRight) / moduleSize);\n    var tlblCentersDimension = MathUtils_1.default.round(ResultPoint_1.default.distance(topLeft, bottomLeft) / moduleSize);\n    var dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;\n\n    switch (dimension & 0x03) {\n      // mod 4\n      case 0:\n        dimension++;\n        break;\n      // 1? do nothing\n\n      case 2:\n        dimension--;\n        break;\n\n      case 3:\n        throw new NotFoundException_1.default('Dimensions could be not found.');\n    }\n\n    return dimension;\n  };\n  /**\n   * <p>Computes an average estimated module size based on estimated derived from the positions\n   * of the three finder patterns.</p>\n   *\n   * @param topLeft detected top-left finder pattern center\n   * @param topRight detected top-right finder pattern center\n   * @param bottomLeft detected bottom-left finder pattern center\n   * @return estimated module size\n   */\n\n\n  Detector.prototype.calculateModuleSize = function (topLeft, topRight, bottomLeft) {\n    // Take the average\n    return (this.calculateModuleSizeOneWay(topLeft, topRight) + this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;\n  };\n  /**\n   * <p>Estimates module size based on two finder patterns -- it uses\n   * {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the\n   * width of each, measuring along the axis between their centers.</p>\n   */\n\n\n  Detector.prototype.calculateModuleSizeOneWay = function (pattern, otherPattern) {\n    var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(\n    /*(int) */\n    Math.floor(pattern.getX()),\n    /*(int) */\n    Math.floor(pattern.getY()),\n    /*(int) */\n    Math.floor(otherPattern.getX()),\n    /*(int) */\n    Math.floor(otherPattern.getY()));\n    var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(\n    /*(int) */\n    Math.floor(otherPattern.getX()),\n    /*(int) */\n    Math.floor(otherPattern.getY()),\n    /*(int) */\n    Math.floor(pattern.getX()),\n    /*(int) */\n    Math.floor(pattern.getY()));\n\n    if (isNaN(moduleSizeEst1)) {\n      return moduleSizeEst2 / 7.0;\n    }\n\n    if (isNaN(moduleSizeEst2)) {\n      return moduleSizeEst1 / 7.0;\n    } // Average them, and divide by 7 since we've counted the width of 3 black modules,\n    // and 1 white and 1 black module on either side. Ergo, divide sum by 14.\n\n\n    return (moduleSizeEst1 + moduleSizeEst2) / 14.0;\n  };\n  /**\n   * See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of\n   * a finder pattern by looking for a black-white-black run from the center in the direction\n   * of another point (another finder pattern center), and in the opposite direction too.\n   */\n\n\n  Detector.prototype.sizeOfBlackWhiteBlackRunBothWays = function (fromX\n  /*int*/\n  , fromY\n  /*int*/\n  , toX\n  /*int*/\n  , toY\n  /*int*/\n  ) {\n    var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY); // Now count other way -- don't run off image though of course\n\n    var scale = 1.0;\n    var otherToX = fromX - (toX - fromX);\n\n    if (otherToX < 0) {\n      scale = fromX / (\n      /*(float) */\n      fromX - otherToX);\n      otherToX = 0;\n    } else if (otherToX >= this.image.getWidth()) {\n      scale = (this.image.getWidth() - 1 - fromX) / (\n      /*(float) */\n      otherToX - fromX);\n      otherToX = this.image.getWidth() - 1;\n    }\n\n    var otherToY =\n    /*(int) */\n    Math.floor(fromY - (toY - fromY) * scale);\n    scale = 1.0;\n\n    if (otherToY < 0) {\n      scale = fromY / (\n      /*(float) */\n      fromY - otherToY);\n      otherToY = 0;\n    } else if (otherToY >= this.image.getHeight()) {\n      scale = (this.image.getHeight() - 1 - fromY) / (\n      /*(float) */\n      otherToY - fromY);\n      otherToY = this.image.getHeight() - 1;\n    }\n\n    otherToX =\n    /*(int) */\n    Math.floor(fromX + (otherToX - fromX) * scale);\n    result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY); // Middle pixel is double-counted this way; subtract 1\n\n    return result - 1.0;\n  };\n  /**\n   * <p>This method traces a line from a point in the image, in the direction towards another point.\n   * It begins in a black region, and keeps going until it finds white, then black, then white again.\n   * It reports the distance from the start to this point.</p>\n   *\n   * <p>This is used when figuring out how wide a finder pattern is, when the finder pattern\n   * may be skewed or rotated.</p>\n   */\n\n\n  Detector.prototype.sizeOfBlackWhiteBlackRun = function (fromX\n  /*int*/\n  , fromY\n  /*int*/\n  , toX\n  /*int*/\n  , toY\n  /*int*/\n  ) {\n    // Mild variant of Bresenham's algorithm\n    // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm\n    var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n\n    if (steep) {\n      var temp = fromX;\n      fromX = fromY;\n      fromY = temp;\n      temp = toX;\n      toX = toY;\n      toY = temp;\n    }\n\n    var dx = Math.abs(toX - fromX);\n    var dy = Math.abs(toY - fromY);\n    var error = -dx / 2;\n    var xstep = fromX < toX ? 1 : -1;\n    var ystep = fromY < toY ? 1 : -1; // In black pixels, looking for white, first or second time.\n\n    var state = 0; // Loop up until x == toX, but not beyond\n\n    var xLimit = toX + xstep;\n\n    for (var x = fromX, y = fromY; x !== xLimit; x += xstep) {\n      var realX = steep ? y : x;\n      var realY = steep ? x : y; // Does current pixel mean we have moved white to black or vice versa?\n      // Scanning black in state 0,2 and white in state 1, so if we find the wrong\n      // color, advance to next state or end if we are in state 2 already\n\n      if (state === 1 === this.image.get(realX, realY)) {\n        if (state === 2) {\n          return MathUtils_1.default.distance(x, y, fromX, fromY);\n        }\n\n        state++;\n      }\n\n      error += dy;\n\n      if (error > 0) {\n        if (y === toY) {\n          break;\n        }\n\n        y += ystep;\n        error -= dx;\n      }\n    } // Found black-white-black; give the benefit of the doubt that the next pixel outside the image\n    // is \"white\" so this last point at (toX+xStep,toY) is the right ending. This is really a\n    // small approximation; (toX+xStep,toY+yStep) might be really correct. Ignore this.\n\n\n    if (state === 2) {\n      return MathUtils_1.default.distance(toX + xstep, toY, fromX, fromY);\n    } // else we didn't find even black-white-black; no estimate is really possible\n\n\n    return NaN;\n  };\n  /**\n   * <p>Attempts to locate an alignment pattern in a limited region of the image, which is\n   * guessed to contain it. This method uses {@link AlignmentPattern}.</p>\n   *\n   * @param overallEstModuleSize estimated module size so far\n   * @param estAlignmentX x coordinate of center of area probably containing alignment pattern\n   * @param estAlignmentY y coordinate of above\n   * @param allowanceFactor number of pixels in all directions to search from the center\n   * @return {@link AlignmentPattern} if found, or null otherwise\n   * @throws NotFoundException if an unexpected error occurs during detection\n   */\n\n\n  Detector.prototype.findAlignmentInRegion = function (overallEstModuleSize\n  /*float*/\n  , estAlignmentX\n  /*int*/\n  , estAlignmentY\n  /*int*/\n  , allowanceFactor\n  /*float*/\n  ) {\n    // Look for an alignment pattern (3 modules in size) around where it\n    // should be\n    var allowance =\n    /*(int) */\n    Math.floor(allowanceFactor * overallEstModuleSize);\n    var alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);\n    var alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);\n\n    if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {\n      throw new NotFoundException_1.default('Alignment top exceeds estimated module size.');\n    }\n\n    var alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);\n    var alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);\n\n    if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {\n      throw new NotFoundException_1.default('Alignment bottom exceeds estimated module size.');\n    }\n\n    var alignmentFinder = new AlignmentPatternFinder_1.default(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);\n    return alignmentFinder.find();\n  };\n\n  return Detector;\n}();\n\nexports.default = Detector;","map":{"version":3,"sources":["../../../../src/core/qrcode/detector/Detector.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.qrcode.detector {*/\nvar DecodeHintType_1 = require(\"../../DecodeHintType\");\nvar ResultPoint_1 = require(\"../../ResultPoint\");\nvar DetectorResult_1 = require(\"../../common/DetectorResult\");\nvar GridSamplerInstance_1 = require(\"../../common/GridSamplerInstance\");\nvar PerspectiveTransform_1 = require(\"../../common/PerspectiveTransform\");\nvar MathUtils_1 = require(\"../../common/detector/MathUtils\");\nvar Version_1 = require(\"../decoder/Version\");\nvar FinderPatternFinder_1 = require(\"./FinderPatternFinder\");\nvar AlignmentPatternFinder_1 = require(\"./AlignmentPatternFinder\");\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/*import java.util.Map;*/\n/**\n * <p>Encapsulates logic that can detect a QR Code in an image, even if the QR Code\n * is rotated or skewed, or partially obscured.</p>\n *\n * @author Sean Owen\n */\nvar Detector = /** @class */ (function () {\n    function Detector(image) {\n        this.image = image;\n    }\n    Detector.prototype.getImage = function () {\n        return this.image;\n    };\n    Detector.prototype.getResultPointCallback = function () {\n        return this.resultPointCallback;\n    };\n    /**\n     * <p>Detects a QR Code in an image.</p>\n     *\n     * @return {@link DetectorResult} encapsulating results of detecting a QR Code\n     * @throws NotFoundException if QR Code cannot be found\n     * @throws FormatException if a QR Code cannot be decoded\n     */\n    // public detect(): DetectorResult /*throws NotFoundException, FormatException*/ {\n    //   return detect(null)\n    // }\n    /**\n     * <p>Detects a QR Code in an image.</p>\n     *\n     * @param hints optional hints to detector\n     * @return {@link DetectorResult} encapsulating results of detecting a QR Code\n     * @throws NotFoundException if QR Code cannot be found\n     * @throws FormatException if a QR Code cannot be decoded\n     */\n    Detector.prototype.detect = function (hints) {\n        this.resultPointCallback = (hints === null || hints === undefined) ? null :\n            /*(ResultPointCallback) */ hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n        var finder = new FinderPatternFinder_1.default(this.image, this.resultPointCallback);\n        var info = finder.find(hints);\n        return this.processFinderPatternInfo(info);\n    };\n    Detector.prototype.processFinderPatternInfo = function (info) {\n        var topLeft = info.getTopLeft();\n        var topRight = info.getTopRight();\n        var bottomLeft = info.getBottomLeft();\n        var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);\n        if (moduleSize < 1.0) {\n            throw new NotFoundException_1.default('No pattern found in proccess finder.');\n        }\n        var dimension = Detector.computeDimension(topLeft, topRight, bottomLeft, moduleSize);\n        var provisionalVersion = Version_1.default.getProvisionalVersionForDimension(dimension);\n        var modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;\n        var alignmentPattern = null;\n        // Anything above version 1 has an alignment pattern\n        if (provisionalVersion.getAlignmentPatternCenters().length > 0) {\n            // Guess where a \"bottom right\" finder pattern would have been\n            var bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();\n            var bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();\n            // Estimate that alignment pattern is closer by 3 modules\n            // from \"bottom right\" to known top left location\n            var correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;\n            var estAlignmentX = /*(int) */ Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));\n            var estAlignmentY = /*(int) */ Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));\n            // Kind of arbitrary -- expand search radius before giving up\n            for (var i = 4; i <= 16; i <<= 1) {\n                try {\n                    alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);\n                    break;\n                }\n                catch (re /*NotFoundException*/) {\n                    if (!(re instanceof NotFoundException_1.default)) {\n                        throw re;\n                    }\n                    // try next round\n                }\n            }\n            // If we didn't find alignment pattern... well try anyway without it\n        }\n        var transform = Detector.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);\n        var bits = Detector.sampleGrid(this.image, transform, dimension);\n        var points;\n        if (alignmentPattern === null) {\n            points = [bottomLeft, topLeft, topRight];\n        }\n        else {\n            points = [bottomLeft, topLeft, topRight, alignmentPattern];\n        }\n        return new DetectorResult_1.default(bits, points);\n    };\n    Detector.createTransform = function (topLeft, topRight, bottomLeft, alignmentPattern, dimension /*int*/) {\n        var dimMinusThree = dimension - 3.5;\n        var bottomRightX; /*float*/\n        var bottomRightY; /*float*/\n        var sourceBottomRightX; /*float*/\n        var sourceBottomRightY; /*float*/\n        if (alignmentPattern !== null) {\n            bottomRightX = alignmentPattern.getX();\n            bottomRightY = alignmentPattern.getY();\n            sourceBottomRightX = dimMinusThree - 3.0;\n            sourceBottomRightY = sourceBottomRightX;\n        }\n        else {\n            // Don't have an alignment pattern, just make up the bottom-right point\n            bottomRightX = (topRight.getX() - topLeft.getX()) + bottomLeft.getX();\n            bottomRightY = (topRight.getY() - topLeft.getY()) + bottomLeft.getY();\n            sourceBottomRightX = dimMinusThree;\n            sourceBottomRightY = dimMinusThree;\n        }\n        return PerspectiveTransform_1.default.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());\n    };\n    Detector.sampleGrid = function (image, transform, dimension /*int*/) {\n        var sampler = GridSamplerInstance_1.default.getInstance();\n        return sampler.sampleGridWithTransform(image, dimension, dimension, transform);\n    };\n    /**\n     * <p>Computes the dimension (number of modules on a size) of the QR Code based on the position\n     * of the finder patterns and estimated module size.</p>\n     */\n    Detector.computeDimension = function (topLeft, topRight, bottomLeft, moduleSize /*float*/) {\n        var tltrCentersDimension = MathUtils_1.default.round(ResultPoint_1.default.distance(topLeft, topRight) / moduleSize);\n        var tlblCentersDimension = MathUtils_1.default.round(ResultPoint_1.default.distance(topLeft, bottomLeft) / moduleSize);\n        var dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;\n        switch (dimension & 0x03) { // mod 4\n            case 0:\n                dimension++;\n                break;\n            // 1? do nothing\n            case 2:\n                dimension--;\n                break;\n            case 3:\n                throw new NotFoundException_1.default('Dimensions could be not found.');\n        }\n        return dimension;\n    };\n    /**\n     * <p>Computes an average estimated module size based on estimated derived from the positions\n     * of the three finder patterns.</p>\n     *\n     * @param topLeft detected top-left finder pattern center\n     * @param topRight detected top-right finder pattern center\n     * @param bottomLeft detected bottom-left finder pattern center\n     * @return estimated module size\n     */\n    Detector.prototype.calculateModuleSize = function (topLeft, topRight, bottomLeft) {\n        // Take the average\n        return (this.calculateModuleSizeOneWay(topLeft, topRight) +\n            this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;\n    };\n    /**\n     * <p>Estimates module size based on two finder patterns -- it uses\n     * {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the\n     * width of each, measuring along the axis between their centers.</p>\n     */\n    Detector.prototype.calculateModuleSizeOneWay = function (pattern, otherPattern) {\n        var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(pattern.getX()), \n        /*(int) */ Math.floor(pattern.getY()), \n        /*(int) */ Math.floor(otherPattern.getX()), \n        /*(int) */ Math.floor(otherPattern.getY()));\n        var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(otherPattern.getX()), \n        /*(int) */ Math.floor(otherPattern.getY()), \n        /*(int) */ Math.floor(pattern.getX()), \n        /*(int) */ Math.floor(pattern.getY()));\n        if (isNaN(moduleSizeEst1)) {\n            return moduleSizeEst2 / 7.0;\n        }\n        if (isNaN(moduleSizeEst2)) {\n            return moduleSizeEst1 / 7.0;\n        }\n        // Average them, and divide by 7 since we've counted the width of 3 black modules,\n        // and 1 white and 1 black module on either side. Ergo, divide sum by 14.\n        return (moduleSizeEst1 + moduleSizeEst2) / 14.0;\n    };\n    /**\n     * See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of\n     * a finder pattern by looking for a black-white-black run from the center in the direction\n     * of another point (another finder pattern center), and in the opposite direction too.\n     */\n    Detector.prototype.sizeOfBlackWhiteBlackRunBothWays = function (fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {\n        var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);\n        // Now count other way -- don't run off image though of course\n        var scale = 1.0;\n        var otherToX = fromX - (toX - fromX);\n        if (otherToX < 0) {\n            scale = fromX / /*(float) */ (fromX - otherToX);\n            otherToX = 0;\n        }\n        else if (otherToX >= this.image.getWidth()) {\n            scale = (this.image.getWidth() - 1 - fromX) / /*(float) */ (otherToX - fromX);\n            otherToX = this.image.getWidth() - 1;\n        }\n        var otherToY = /*(int) */ Math.floor(fromY - (toY - fromY) * scale);\n        scale = 1.0;\n        if (otherToY < 0) {\n            scale = fromY / /*(float) */ (fromY - otherToY);\n            otherToY = 0;\n        }\n        else if (otherToY >= this.image.getHeight()) {\n            scale = (this.image.getHeight() - 1 - fromY) / /*(float) */ (otherToY - fromY);\n            otherToY = this.image.getHeight() - 1;\n        }\n        otherToX = /*(int) */ Math.floor(fromX + (otherToX - fromX) * scale);\n        result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);\n        // Middle pixel is double-counted this way; subtract 1\n        return result - 1.0;\n    };\n    /**\n     * <p>This method traces a line from a point in the image, in the direction towards another point.\n     * It begins in a black region, and keeps going until it finds white, then black, then white again.\n     * It reports the distance from the start to this point.</p>\n     *\n     * <p>This is used when figuring out how wide a finder pattern is, when the finder pattern\n     * may be skewed or rotated.</p>\n     */\n    Detector.prototype.sizeOfBlackWhiteBlackRun = function (fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {\n        // Mild variant of Bresenham's algorithm\n        // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm\n        var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n        if (steep) {\n            var temp = fromX;\n            fromX = fromY;\n            fromY = temp;\n            temp = toX;\n            toX = toY;\n            toY = temp;\n        }\n        var dx = Math.abs(toX - fromX);\n        var dy = Math.abs(toY - fromY);\n        var error = -dx / 2;\n        var xstep = fromX < toX ? 1 : -1;\n        var ystep = fromY < toY ? 1 : -1;\n        // In black pixels, looking for white, first or second time.\n        var state = 0;\n        // Loop up until x == toX, but not beyond\n        var xLimit = toX + xstep;\n        for (var x = fromX, y = fromY; x !== xLimit; x += xstep) {\n            var realX = steep ? y : x;\n            var realY = steep ? x : y;\n            // Does current pixel mean we have moved white to black or vice versa?\n            // Scanning black in state 0,2 and white in state 1, so if we find the wrong\n            // color, advance to next state or end if we are in state 2 already\n            if ((state === 1) === this.image.get(realX, realY)) {\n                if (state === 2) {\n                    return MathUtils_1.default.distance(x, y, fromX, fromY);\n                }\n                state++;\n            }\n            error += dy;\n            if (error > 0) {\n                if (y === toY) {\n                    break;\n                }\n                y += ystep;\n                error -= dx;\n            }\n        }\n        // Found black-white-black; give the benefit of the doubt that the next pixel outside the image\n        // is \"white\" so this last point at (toX+xStep,toY) is the right ending. This is really a\n        // small approximation; (toX+xStep,toY+yStep) might be really correct. Ignore this.\n        if (state === 2) {\n            return MathUtils_1.default.distance(toX + xstep, toY, fromX, fromY);\n        }\n        // else we didn't find even black-white-black; no estimate is really possible\n        return NaN;\n    };\n    /**\n     * <p>Attempts to locate an alignment pattern in a limited region of the image, which is\n     * guessed to contain it. This method uses {@link AlignmentPattern}.</p>\n     *\n     * @param overallEstModuleSize estimated module size so far\n     * @param estAlignmentX x coordinate of center of area probably containing alignment pattern\n     * @param estAlignmentY y coordinate of above\n     * @param allowanceFactor number of pixels in all directions to search from the center\n     * @return {@link AlignmentPattern} if found, or null otherwise\n     * @throws NotFoundException if an unexpected error occurs during detection\n     */\n    Detector.prototype.findAlignmentInRegion = function (overallEstModuleSize /*float*/, estAlignmentX /*int*/, estAlignmentY /*int*/, allowanceFactor /*float*/) {\n        // Look for an alignment pattern (3 modules in size) around where it\n        // should be\n        var allowance = /*(int) */ Math.floor(allowanceFactor * overallEstModuleSize);\n        var alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);\n        var alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);\n        if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {\n            throw new NotFoundException_1.default('Alignment top exceeds estimated module size.');\n        }\n        var alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);\n        var alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);\n        if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {\n            throw new NotFoundException_1.default('Alignment bottom exceeds estimated module size.');\n        }\n        var alignmentFinder = new AlignmentPatternFinder_1.default(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);\n        return alignmentFinder.find();\n    };\n    return Detector;\n}());\nexports.default = Detector;\n//# sourceMappingURL=Detector.js.map"]},"metadata":{},"sourceType":"script"}
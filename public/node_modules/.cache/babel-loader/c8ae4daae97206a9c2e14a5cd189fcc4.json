{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ResultPoint_1 = require(\"../../ResultPoint\");\n\nvar DetectorResult_1 = require(\"../../common/DetectorResult\");\n\nvar GridSamplerInstance_1 = require(\"../../common/GridSamplerInstance\");\n\nvar WhiteRectangleDetector_1 = require(\"../../common/detector/WhiteRectangleDetector\");\n\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * <p>Encapsulates logic that can detect a Data Matrix Code in an image, even if the Data Matrix Code\n * is rotated or skewed, or partially obscured.</p>\n *\n * @author Sean Owen\n */\n\n\nvar Detector =\n/** @class */\nfunction () {\n  function Detector(image) {\n    this.image = image;\n    this.rectangleDetector = new WhiteRectangleDetector_1.default(this.image);\n  }\n  /**\n   * <p>Detects a Data Matrix Code in an image.</p>\n   *\n   * @return {@link DetectorResult} encapsulating results of detecting a Data Matrix Code\n   * @throws NotFoundException if no Data Matrix Code can be found\n   */\n\n\n  Detector.prototype.detect = function () {\n    var cornerPoints = this.rectangleDetector.detect();\n    var points = this.detectSolid1(cornerPoints);\n    points = this.detectSolid2(points);\n    points[3] = this.correctTopRight(points);\n\n    if (!points[3]) {\n      throw new NotFoundException_1.default();\n    }\n\n    points = this.shiftToModuleCenter(points);\n    var topLeft = points[0];\n    var bottomLeft = points[1];\n    var bottomRight = points[2];\n    var topRight = points[3];\n    var dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;\n    var dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;\n\n    if ((dimensionTop & 0x01) === 1) {\n      dimensionTop += 1;\n    }\n\n    if ((dimensionRight & 0x01) === 1) {\n      dimensionRight += 1;\n    }\n\n    if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {\n      // The matrix is square\n      dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);\n    }\n\n    var bits = Detector.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);\n    return new DetectorResult_1.default(bits, [topLeft, bottomLeft, bottomRight, topRight]);\n  };\n\n  Detector.shiftPoint = function (point, to, div) {\n    var x = (to.getX() - point.getX()) / (div + 1);\n    var y = (to.getY() - point.getY()) / (div + 1);\n    return new ResultPoint_1.default(point.getX() + x, point.getY() + y);\n  };\n\n  Detector.moveAway = function (point, fromX, fromY) {\n    var x = point.getX();\n    var y = point.getY();\n\n    if (x < fromX) {\n      x -= 1;\n    } else {\n      x += 1;\n    }\n\n    if (y < fromY) {\n      y -= 1;\n    } else {\n      y += 1;\n    }\n\n    return new ResultPoint_1.default(x, y);\n  };\n  /**\n   * Detect a solid side which has minimum transition.\n   */\n\n\n  Detector.prototype.detectSolid1 = function (cornerPoints) {\n    // 0  2\n    // 1  3\n    var pointA = cornerPoints[0];\n    var pointB = cornerPoints[1];\n    var pointC = cornerPoints[3];\n    var pointD = cornerPoints[2];\n    var trAB = this.transitionsBetween(pointA, pointB);\n    var trBC = this.transitionsBetween(pointB, pointC);\n    var trCD = this.transitionsBetween(pointC, pointD);\n    var trDA = this.transitionsBetween(pointD, pointA); // 0..3\n    // :  :\n    // 1--2\n\n    var min = trAB;\n    var points = [pointD, pointA, pointB, pointC];\n\n    if (min > trBC) {\n      min = trBC;\n      points[0] = pointA;\n      points[1] = pointB;\n      points[2] = pointC;\n      points[3] = pointD;\n    }\n\n    if (min > trCD) {\n      min = trCD;\n      points[0] = pointB;\n      points[1] = pointC;\n      points[2] = pointD;\n      points[3] = pointA;\n    }\n\n    if (min > trDA) {\n      points[0] = pointC;\n      points[1] = pointD;\n      points[2] = pointA;\n      points[3] = pointB;\n    }\n\n    return points;\n  };\n  /**\n   * Detect a second solid side next to first solid side.\n   */\n\n\n  Detector.prototype.detectSolid2 = function (points) {\n    // A..D\n    // :  :\n    // B--C\n    var pointA = points[0];\n    var pointB = points[1];\n    var pointC = points[2];\n    var pointD = points[3]; // Transition detection on the edge is not stable.\n    // To safely detect, shift the points to the module center.\n\n    var tr = this.transitionsBetween(pointA, pointD);\n    var pointBs = Detector.shiftPoint(pointB, pointC, (tr + 1) * 4);\n    var pointCs = Detector.shiftPoint(pointC, pointB, (tr + 1) * 4);\n    var trBA = this.transitionsBetween(pointBs, pointA);\n    var trCD = this.transitionsBetween(pointCs, pointD); // 0..3\n    // |  :\n    // 1--2\n\n    if (trBA < trCD) {\n      // solid sides: A-B-C\n      points[0] = pointA;\n      points[1] = pointB;\n      points[2] = pointC;\n      points[3] = pointD;\n    } else {\n      // solid sides: B-C-D\n      points[0] = pointB;\n      points[1] = pointC;\n      points[2] = pointD;\n      points[3] = pointA;\n    }\n\n    return points;\n  };\n  /**\n   * Calculates the corner position of the white top right module.\n   */\n\n\n  Detector.prototype.correctTopRight = function (points) {\n    // A..D\n    // |  :\n    // B--C\n    var pointA = points[0];\n    var pointB = points[1];\n    var pointC = points[2];\n    var pointD = points[3]; // shift points for safe transition detection.\n\n    var trTop = this.transitionsBetween(pointA, pointD);\n    var trRight = this.transitionsBetween(pointB, pointD);\n    var pointAs = Detector.shiftPoint(pointA, pointB, (trRight + 1) * 4);\n    var pointCs = Detector.shiftPoint(pointC, pointB, (trTop + 1) * 4);\n    trTop = this.transitionsBetween(pointAs, pointD);\n    trRight = this.transitionsBetween(pointCs, pointD);\n    var candidate1 = new ResultPoint_1.default(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));\n    var candidate2 = new ResultPoint_1.default(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));\n\n    if (!this.isValid(candidate1)) {\n      if (this.isValid(candidate2)) {\n        return candidate2;\n      }\n\n      return null;\n    }\n\n    if (!this.isValid(candidate2)) {\n      return candidate1;\n    }\n\n    var sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);\n    var sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);\n\n    if (sumc1 > sumc2) {\n      return candidate1;\n    } else {\n      return candidate2;\n    }\n  };\n  /**\n   * Shift the edge points to the module center.\n   */\n\n\n  Detector.prototype.shiftToModuleCenter = function (points) {\n    // A..D\n    // |  :\n    // B--C\n    var pointA = points[0];\n    var pointB = points[1];\n    var pointC = points[2];\n    var pointD = points[3]; // calculate pseudo dimensions\n\n    var dimH = this.transitionsBetween(pointA, pointD) + 1;\n    var dimV = this.transitionsBetween(pointC, pointD) + 1; // shift points for safe dimension detection\n\n    var pointAs = Detector.shiftPoint(pointA, pointB, dimV * 4);\n    var pointCs = Detector.shiftPoint(pointC, pointB, dimH * 4); //  calculate more precise dimensions\n\n    dimH = this.transitionsBetween(pointAs, pointD) + 1;\n    dimV = this.transitionsBetween(pointCs, pointD) + 1;\n\n    if ((dimH & 0x01) === 1) {\n      dimH += 1;\n    }\n\n    if ((dimV & 0x01) === 1) {\n      dimV += 1;\n    } // WhiteRectangleDetector returns points inside of the rectangle.\n    // I want points on the edges.\n\n\n    var centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;\n    var centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;\n    pointA = Detector.moveAway(pointA, centerX, centerY);\n    pointB = Detector.moveAway(pointB, centerX, centerY);\n    pointC = Detector.moveAway(pointC, centerX, centerY);\n    pointD = Detector.moveAway(pointD, centerX, centerY);\n    var pointBs;\n    var pointDs; // shift points to the center of each modules\n\n    pointAs = Detector.shiftPoint(pointA, pointB, dimV * 4);\n    pointAs = Detector.shiftPoint(pointAs, pointD, dimH * 4);\n    pointBs = Detector.shiftPoint(pointB, pointA, dimV * 4);\n    pointBs = Detector.shiftPoint(pointBs, pointC, dimH * 4);\n    pointCs = Detector.shiftPoint(pointC, pointD, dimV * 4);\n    pointCs = Detector.shiftPoint(pointCs, pointB, dimH * 4);\n    pointDs = Detector.shiftPoint(pointD, pointC, dimV * 4);\n    pointDs = Detector.shiftPoint(pointDs, pointA, dimH * 4);\n    return [pointAs, pointBs, pointCs, pointDs];\n  };\n\n  Detector.prototype.isValid = function (p) {\n    return p.getX() >= 0 && p.getX() < this.image.getWidth() && p.getY() > 0 && p.getY() < this.image.getHeight();\n  };\n\n  Detector.sampleGrid = function (image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {\n    var sampler = GridSamplerInstance_1.default.getInstance();\n    return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n  };\n  /**\n   * Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.\n   */\n\n\n  Detector.prototype.transitionsBetween = function (from, to) {\n    // See QR Code Detector, sizeOfBlackWhiteBlackRun()\n    var fromX = Math.trunc(from.getX());\n    var fromY = Math.trunc(from.getY());\n    var toX = Math.trunc(to.getX());\n    var toY = Math.trunc(to.getY());\n    var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n\n    if (steep) {\n      var temp = fromX;\n      fromX = fromY;\n      fromY = temp;\n      temp = toX;\n      toX = toY;\n      toY = temp;\n    }\n\n    var dx = Math.abs(toX - fromX);\n    var dy = Math.abs(toY - fromY);\n    var error = -dx / 2;\n    var ystep = fromY < toY ? 1 : -1;\n    var xstep = fromX < toX ? 1 : -1;\n    var transitions = 0;\n    var inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);\n\n    for (var x = fromX, y = fromY; x !== toX; x += xstep) {\n      var isBlack = this.image.get(steep ? y : x, steep ? x : y);\n\n      if (isBlack !== inBlack) {\n        transitions++;\n        inBlack = isBlack;\n      }\n\n      error += dy;\n\n      if (error > 0) {\n        if (y === toY) {\n          break;\n        }\n\n        y += ystep;\n        error -= dx;\n      }\n    }\n\n    return transitions;\n  };\n\n  return Detector;\n}();\n\nexports.default = Detector;","map":{"version":3,"sources":["../../../../src/core/datamatrix/detector/Detector.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ResultPoint_1 = require(\"../../ResultPoint\");\nvar DetectorResult_1 = require(\"../../common/DetectorResult\");\nvar GridSamplerInstance_1 = require(\"../../common/GridSamplerInstance\");\nvar WhiteRectangleDetector_1 = require(\"../../common/detector/WhiteRectangleDetector\");\nvar NotFoundException_1 = require(\"../../NotFoundException\");\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * <p>Encapsulates logic that can detect a Data Matrix Code in an image, even if the Data Matrix Code\n * is rotated or skewed, or partially obscured.</p>\n *\n * @author Sean Owen\n */\nvar Detector = /** @class */ (function () {\n    function Detector(image) {\n        this.image = image;\n        this.rectangleDetector = new WhiteRectangleDetector_1.default(this.image);\n    }\n    /**\n     * <p>Detects a Data Matrix Code in an image.</p>\n     *\n     * @return {@link DetectorResult} encapsulating results of detecting a Data Matrix Code\n     * @throws NotFoundException if no Data Matrix Code can be found\n     */\n    Detector.prototype.detect = function () {\n        var cornerPoints = this.rectangleDetector.detect();\n        var points = this.detectSolid1(cornerPoints);\n        points = this.detectSolid2(points);\n        points[3] = this.correctTopRight(points);\n        if (!points[3]) {\n            throw new NotFoundException_1.default();\n        }\n        points = this.shiftToModuleCenter(points);\n        var topLeft = points[0];\n        var bottomLeft = points[1];\n        var bottomRight = points[2];\n        var topRight = points[3];\n        var dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;\n        var dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;\n        if ((dimensionTop & 0x01) === 1) {\n            dimensionTop += 1;\n        }\n        if ((dimensionRight & 0x01) === 1) {\n            dimensionRight += 1;\n        }\n        if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {\n            // The matrix is square\n            dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);\n        }\n        var bits = Detector.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);\n        return new DetectorResult_1.default(bits, [topLeft, bottomLeft, bottomRight, topRight]);\n    };\n    Detector.shiftPoint = function (point, to, div) {\n        var x = (to.getX() - point.getX()) / (div + 1);\n        var y = (to.getY() - point.getY()) / (div + 1);\n        return new ResultPoint_1.default(point.getX() + x, point.getY() + y);\n    };\n    Detector.moveAway = function (point, fromX, fromY) {\n        var x = point.getX();\n        var y = point.getY();\n        if (x < fromX) {\n            x -= 1;\n        }\n        else {\n            x += 1;\n        }\n        if (y < fromY) {\n            y -= 1;\n        }\n        else {\n            y += 1;\n        }\n        return new ResultPoint_1.default(x, y);\n    };\n    /**\n     * Detect a solid side which has minimum transition.\n     */\n    Detector.prototype.detectSolid1 = function (cornerPoints) {\n        // 0  2\n        // 1  3\n        var pointA = cornerPoints[0];\n        var pointB = cornerPoints[1];\n        var pointC = cornerPoints[3];\n        var pointD = cornerPoints[2];\n        var trAB = this.transitionsBetween(pointA, pointB);\n        var trBC = this.transitionsBetween(pointB, pointC);\n        var trCD = this.transitionsBetween(pointC, pointD);\n        var trDA = this.transitionsBetween(pointD, pointA);\n        // 0..3\n        // :  :\n        // 1--2\n        var min = trAB;\n        var points = [pointD, pointA, pointB, pointC];\n        if (min > trBC) {\n            min = trBC;\n            points[0] = pointA;\n            points[1] = pointB;\n            points[2] = pointC;\n            points[3] = pointD;\n        }\n        if (min > trCD) {\n            min = trCD;\n            points[0] = pointB;\n            points[1] = pointC;\n            points[2] = pointD;\n            points[3] = pointA;\n        }\n        if (min > trDA) {\n            points[0] = pointC;\n            points[1] = pointD;\n            points[2] = pointA;\n            points[3] = pointB;\n        }\n        return points;\n    };\n    /**\n     * Detect a second solid side next to first solid side.\n     */\n    Detector.prototype.detectSolid2 = function (points) {\n        // A..D\n        // :  :\n        // B--C\n        var pointA = points[0];\n        var pointB = points[1];\n        var pointC = points[2];\n        var pointD = points[3];\n        // Transition detection on the edge is not stable.\n        // To safely detect, shift the points to the module center.\n        var tr = this.transitionsBetween(pointA, pointD);\n        var pointBs = Detector.shiftPoint(pointB, pointC, (tr + 1) * 4);\n        var pointCs = Detector.shiftPoint(pointC, pointB, (tr + 1) * 4);\n        var trBA = this.transitionsBetween(pointBs, pointA);\n        var trCD = this.transitionsBetween(pointCs, pointD);\n        // 0..3\n        // |  :\n        // 1--2\n        if (trBA < trCD) {\n            // solid sides: A-B-C\n            points[0] = pointA;\n            points[1] = pointB;\n            points[2] = pointC;\n            points[3] = pointD;\n        }\n        else {\n            // solid sides: B-C-D\n            points[0] = pointB;\n            points[1] = pointC;\n            points[2] = pointD;\n            points[3] = pointA;\n        }\n        return points;\n    };\n    /**\n     * Calculates the corner position of the white top right module.\n     */\n    Detector.prototype.correctTopRight = function (points) {\n        // A..D\n        // |  :\n        // B--C\n        var pointA = points[0];\n        var pointB = points[1];\n        var pointC = points[2];\n        var pointD = points[3];\n        // shift points for safe transition detection.\n        var trTop = this.transitionsBetween(pointA, pointD);\n        var trRight = this.transitionsBetween(pointB, pointD);\n        var pointAs = Detector.shiftPoint(pointA, pointB, (trRight + 1) * 4);\n        var pointCs = Detector.shiftPoint(pointC, pointB, (trTop + 1) * 4);\n        trTop = this.transitionsBetween(pointAs, pointD);\n        trRight = this.transitionsBetween(pointCs, pointD);\n        var candidate1 = new ResultPoint_1.default(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));\n        var candidate2 = new ResultPoint_1.default(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));\n        if (!this.isValid(candidate1)) {\n            if (this.isValid(candidate2)) {\n                return candidate2;\n            }\n            return null;\n        }\n        if (!this.isValid(candidate2)) {\n            return candidate1;\n        }\n        var sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);\n        var sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);\n        if (sumc1 > sumc2) {\n            return candidate1;\n        }\n        else {\n            return candidate2;\n        }\n    };\n    /**\n     * Shift the edge points to the module center.\n     */\n    Detector.prototype.shiftToModuleCenter = function (points) {\n        // A..D\n        // |  :\n        // B--C\n        var pointA = points[0];\n        var pointB = points[1];\n        var pointC = points[2];\n        var pointD = points[3];\n        // calculate pseudo dimensions\n        var dimH = this.transitionsBetween(pointA, pointD) + 1;\n        var dimV = this.transitionsBetween(pointC, pointD) + 1;\n        // shift points for safe dimension detection\n        var pointAs = Detector.shiftPoint(pointA, pointB, dimV * 4);\n        var pointCs = Detector.shiftPoint(pointC, pointB, dimH * 4);\n        //  calculate more precise dimensions\n        dimH = this.transitionsBetween(pointAs, pointD) + 1;\n        dimV = this.transitionsBetween(pointCs, pointD) + 1;\n        if ((dimH & 0x01) === 1) {\n            dimH += 1;\n        }\n        if ((dimV & 0x01) === 1) {\n            dimV += 1;\n        }\n        // WhiteRectangleDetector returns points inside of the rectangle.\n        // I want points on the edges.\n        var centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;\n        var centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;\n        pointA = Detector.moveAway(pointA, centerX, centerY);\n        pointB = Detector.moveAway(pointB, centerX, centerY);\n        pointC = Detector.moveAway(pointC, centerX, centerY);\n        pointD = Detector.moveAway(pointD, centerX, centerY);\n        var pointBs;\n        var pointDs;\n        // shift points to the center of each modules\n        pointAs = Detector.shiftPoint(pointA, pointB, dimV * 4);\n        pointAs = Detector.shiftPoint(pointAs, pointD, dimH * 4);\n        pointBs = Detector.shiftPoint(pointB, pointA, dimV * 4);\n        pointBs = Detector.shiftPoint(pointBs, pointC, dimH * 4);\n        pointCs = Detector.shiftPoint(pointC, pointD, dimV * 4);\n        pointCs = Detector.shiftPoint(pointCs, pointB, dimH * 4);\n        pointDs = Detector.shiftPoint(pointD, pointC, dimV * 4);\n        pointDs = Detector.shiftPoint(pointDs, pointA, dimH * 4);\n        return [pointAs, pointBs, pointCs, pointDs];\n    };\n    Detector.prototype.isValid = function (p) {\n        return p.getX() >= 0 && p.getX() < this.image.getWidth() && p.getY() > 0 && p.getY() < this.image.getHeight();\n    };\n    Detector.sampleGrid = function (image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {\n        var sampler = GridSamplerInstance_1.default.getInstance();\n        return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n    };\n    /**\n     * Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.\n     */\n    Detector.prototype.transitionsBetween = function (from, to) {\n        // See QR Code Detector, sizeOfBlackWhiteBlackRun()\n        var fromX = Math.trunc(from.getX());\n        var fromY = Math.trunc(from.getY());\n        var toX = Math.trunc(to.getX());\n        var toY = Math.trunc(to.getY());\n        var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n        if (steep) {\n            var temp = fromX;\n            fromX = fromY;\n            fromY = temp;\n            temp = toX;\n            toX = toY;\n            toY = temp;\n        }\n        var dx = Math.abs(toX - fromX);\n        var dy = Math.abs(toY - fromY);\n        var error = -dx / 2;\n        var ystep = fromY < toY ? 1 : -1;\n        var xstep = fromX < toX ? 1 : -1;\n        var transitions = 0;\n        var inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);\n        for (var x = fromX, y = fromY; x !== toX; x += xstep) {\n            var isBlack = this.image.get(steep ? y : x, steep ? x : y);\n            if (isBlack !== inBlack) {\n                transitions++;\n                inBlack = isBlack;\n            }\n            error += dy;\n            if (error > 0) {\n                if (y === toY) {\n                    break;\n                }\n                y += ystep;\n                error -= dx;\n            }\n        }\n        return transitions;\n    };\n    return Detector;\n}());\nexports.default = Detector;\n//# sourceMappingURL=Detector.js.map"]},"metadata":{},"sourceType":"script"}
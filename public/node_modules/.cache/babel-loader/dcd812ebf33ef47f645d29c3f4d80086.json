{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar IndexOutOfBoundsException_1 = require(\"../IndexOutOfBoundsException\");\n\nvar NullPointerException_1 = require(\"../NullPointerException\");\n/*\n * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n// package java.io;\n\n/**\n * This abstract class is the superclass of all classes representing\n * an output stream of bytes. An output stream accepts output bytes\n * and sends them to some sink.\n * <p>\n * Applications that need to define a subclass of\n * <code>OutputStream</code> must always provide at least a method\n * that writes one byte of output.\n *\n * @author  Arthur van Hoff\n * @see     java.io.BufferedOutputStream\n * @see     java.io.ByteArrayOutputStream\n * @see     java.io.DataOutputStream\n * @see     java.io.FilterOutputStream\n * @see     java.io.InputStream\n * @see     java.io.OutputStream#write(int)\n * @since   JDK1.0\n */\n\n\nvar OutputStream\n/*implements Closeable, Flushable*/\n=\n/** @class */\nfunction () {\n  function OutputStream() {}\n  /**\n   * Writes <code>b.length</code> bytes from the specified byte array\n   * to this output stream. The general contract for <code>write(b)</code>\n   * is that it should have exactly the same effect as the call\n   * <code>write(b, 0, b.length)</code>.\n   *\n   * @param      b   the data.\n   * @exception  IOException  if an I/O error occurs.\n   * @see        java.io.OutputStream#write(byte[], int, int)\n   */\n\n\n  OutputStream.prototype.writeBytes = function (b) {\n    this.writeBytesOffset(b, 0, b.length);\n  };\n  /**\n   * Writes <code>len</code> bytes from the specified byte array\n   * starting at offset <code>off</code> to this output stream.\n   * The general contract for <code>write(b, off, len)</code> is that\n   * some of the bytes in the array <code>b</code> are written to the\n   * output stream in order; element <code>b[off]</code> is the first\n   * byte written and <code>b[off+len-1]</code> is the last byte written\n   * by this operation.\n   * <p>\n   * The <code>write</code> method of <code>OutputStream</code> calls\n   * the write method of one argument on each of the bytes to be\n   * written out. Subclasses are encouraged to override this method and\n   * provide a more efficient implementation.\n   * <p>\n   * If <code>b</code> is <code>null</code>, a\n   * <code>NullPointerException</code> is thrown.\n   * <p>\n   * If <code>off</code> is negative, or <code>len</code> is negative, or\n   * <code>off+len</code> is greater than the length of the array\n   * <code>b</code>, then an <tt>IndexOutOfBoundsException</tt> is thrown.\n   *\n   * @param      b     the data.\n   * @param      off   the start offset in the data.\n   * @param      len   the number of bytes to write.\n   * @exception  IOException  if an I/O error occurs. In particular,\n   *             an <code>IOException</code> is thrown if the output\n   *             stream is closed.\n   */\n\n\n  OutputStream.prototype.writeBytesOffset = function (b, off, len) {\n    if (b == null) {\n      throw new NullPointerException_1.default();\n    } else if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {\n      throw new IndexOutOfBoundsException_1.default();\n    } else if (len === 0) {\n      return;\n    }\n\n    for (var i = 0; i < len; i++) {\n      this.write(b[off + i]);\n    }\n  };\n  /**\n   * Flushes this output stream and forces any buffered output bytes\n   * to be written out. The general contract of <code>flush</code> is\n   * that calling it is an indication that, if any bytes previously\n   * written have been buffered by the implementation of the output\n   * stream, such bytes should immediately be written to their\n   * intended destination.\n   * <p>\n   * If the intended destination of this stream is an abstraction provided by\n   * the underlying operating system, for example a file, then flushing the\n   * stream guarantees only that bytes previously written to the stream are\n   * passed to the operating system for writing; it does not guarantee that\n   * they are actually written to a physical device such as a disk drive.\n   * <p>\n   * The <code>flush</code> method of <code>OutputStream</code> does nothing.\n   *\n   * @exception  IOException  if an I/O error occurs.\n   */\n\n\n  OutputStream.prototype.flush = function () {};\n  /**\n   * Closes this output stream and releases any system resources\n   * associated with this stream. The general contract of <code>close</code>\n   * is that it closes the output stream. A closed stream cannot perform\n   * output operations and cannot be reopened.\n   * <p>\n   * The <code>close</code> method of <code>OutputStream</code> does nothing.\n   *\n   * @exception  IOException  if an I/O error occurs.\n   */\n\n\n  OutputStream.prototype.close = function () {};\n\n  return OutputStream;\n}();\n\nexports.default = OutputStream;","map":{"version":3,"sources":["../../../src/core/util/OutputStream.ts"],"names":[],"mappings":";;;;;;AAAA,IAAA,2BAAA,GAAA,OAAA,CAAA,8BAAA,CAAA;;AACA,IAAA,sBAAA,GAAA,OAAA,CAAA,yBAAA,CAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;AAuBG;AAEH;;AAEA;;;;;;;;;;;;;;;;;AAiBG;;;AACH,IAAA;AAAsD;AAAtD;AAAyF;AAAA,YAAA;AAAzF,WAAA,YAAA,GAAA,CA4GC;AA1FC;;;;;;;;;AASG;;;AACI,EAAA,YAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,CAAlB,EAA+B;AAC7B,SAAK,gBAAL,CAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAAC,CAAC,MAA9B;AACD,GAFM;AAIP;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BG;;;AACI,EAAA,YAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,CAAxB,EAAuC,GAAvC,EAA4D,GAA5D,EAA+E;AAC7E,QAAI,CAAC,IAAI,IAAT,EAAe;AACb,YAAM,IAAI,sBAAA,CAAA,OAAJ,EAAN;AACD,KAFD,MAEO,IAAK,GAAG,GAAG,CAAP,IAAc,GAAG,GAAG,CAAC,CAAC,MAAtB,IAAkC,GAAG,GAAG,CAAxC,IACP,GAAG,GAAG,GAAP,GAAc,CAAC,CAAC,MADR,IACqB,GAAG,GAAG,GAAP,GAAc,CADtC,EAC0C;AAC/C,YAAM,IAAI,2BAAA,CAAA,OAAJ,EAAN;AACD,KAHM,MAGA,IAAI,GAAG,KAAK,CAAZ,EAAe;AACpB;AACD;;AACD,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,EAA1B,EAA8B;AAC5B,WAAK,KAAL,CAAW,CAAC,CAAC,GAAG,GAAG,CAAP,CAAZ;AACD;AACF,GAZM;AAcP;;;;;;;;;;;;;;;;;AAiBG;;;AACI,EAAA,YAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA,CACC,CADM;AAGP;;;;;;;;;AASG;;;AACI,EAAA,YAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA,CACC,CADM;;AAGT,SAAA,YAAA;AAAC,CA5GwF,EAAzF","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar IndexOutOfBoundsException_1 = require(\"../IndexOutOfBoundsException\");\nvar NullPointerException_1 = require(\"../NullPointerException\");\n/*\n * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n// package java.io;\n/**\n * This abstract class is the superclass of all classes representing\n * an output stream of bytes. An output stream accepts output bytes\n * and sends them to some sink.\n * <p>\n * Applications that need to define a subclass of\n * <code>OutputStream</code> must always provide at least a method\n * that writes one byte of output.\n *\n * @author  Arthur van Hoff\n * @see     java.io.BufferedOutputStream\n * @see     java.io.ByteArrayOutputStream\n * @see     java.io.DataOutputStream\n * @see     java.io.FilterOutputStream\n * @see     java.io.InputStream\n * @see     java.io.OutputStream#write(int)\n * @since   JDK1.0\n */\nvar OutputStream /*implements Closeable, Flushable*/ = /** @class */ (function () {\n    function OutputStream() {\n    }\n    /**\n     * Writes <code>b.length</code> bytes from the specified byte array\n     * to this output stream. The general contract for <code>write(b)</code>\n     * is that it should have exactly the same effect as the call\n     * <code>write(b, 0, b.length)</code>.\n     *\n     * @param      b   the data.\n     * @exception  IOException  if an I/O error occurs.\n     * @see        java.io.OutputStream#write(byte[], int, int)\n     */\n    OutputStream.prototype.writeBytes = function (b) {\n        this.writeBytesOffset(b, 0, b.length);\n    };\n    /**\n     * Writes <code>len</code> bytes from the specified byte array\n     * starting at offset <code>off</code> to this output stream.\n     * The general contract for <code>write(b, off, len)</code> is that\n     * some of the bytes in the array <code>b</code> are written to the\n     * output stream in order; element <code>b[off]</code> is the first\n     * byte written and <code>b[off+len-1]</code> is the last byte written\n     * by this operation.\n     * <p>\n     * The <code>write</code> method of <code>OutputStream</code> calls\n     * the write method of one argument on each of the bytes to be\n     * written out. Subclasses are encouraged to override this method and\n     * provide a more efficient implementation.\n     * <p>\n     * If <code>b</code> is <code>null</code>, a\n     * <code>NullPointerException</code> is thrown.\n     * <p>\n     * If <code>off</code> is negative, or <code>len</code> is negative, or\n     * <code>off+len</code> is greater than the length of the array\n     * <code>b</code>, then an <tt>IndexOutOfBoundsException</tt> is thrown.\n     *\n     * @param      b     the data.\n     * @param      off   the start offset in the data.\n     * @param      len   the number of bytes to write.\n     * @exception  IOException  if an I/O error occurs. In particular,\n     *             an <code>IOException</code> is thrown if the output\n     *             stream is closed.\n     */\n    OutputStream.prototype.writeBytesOffset = function (b, off, len) {\n        if (b == null) {\n            throw new NullPointerException_1.default();\n        }\n        else if ((off < 0) || (off > b.length) || (len < 0) ||\n            ((off + len) > b.length) || ((off + len) < 0)) {\n            throw new IndexOutOfBoundsException_1.default();\n        }\n        else if (len === 0) {\n            return;\n        }\n        for (var i = 0; i < len; i++) {\n            this.write(b[off + i]);\n        }\n    };\n    /**\n     * Flushes this output stream and forces any buffered output bytes\n     * to be written out. The general contract of <code>flush</code> is\n     * that calling it is an indication that, if any bytes previously\n     * written have been buffered by the implementation of the output\n     * stream, such bytes should immediately be written to their\n     * intended destination.\n     * <p>\n     * If the intended destination of this stream is an abstraction provided by\n     * the underlying operating system, for example a file, then flushing the\n     * stream guarantees only that bytes previously written to the stream are\n     * passed to the operating system for writing; it does not guarantee that\n     * they are actually written to a physical device such as a disk drive.\n     * <p>\n     * The <code>flush</code> method of <code>OutputStream</code> does nothing.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n    OutputStream.prototype.flush = function () {\n    };\n    /**\n     * Closes this output stream and releases any system resources\n     * associated with this stream. The general contract of <code>close</code>\n     * is that it closes the output stream. A closed stream cannot perform\n     * output operations and cannot be reopened.\n     * <p>\n     * The <code>close</code> method of <code>OutputStream</code> does nothing.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n    OutputStream.prototype.close = function () {\n    };\n    return OutputStream;\n}());\nexports.default = OutputStream;\n//# sourceMappingURL=OutputStream.js.map"]},"metadata":{},"sourceType":"script"}
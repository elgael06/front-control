{"ast":null,"code":"\"use strict\";\n/*\n * Copyright (C) 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.common {*/\n\n/*import java.nio.charset.Charset;*/\n\n/*import java.util.Map;*/\n\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\n\nvar CharacterSetECI_1 = require(\"./CharacterSetECI\");\n\nvar StringEncoding_1 = require(\"../util/StringEncoding\");\n/**\n * Common string-related functions.\n *\n * @author Sean Owen\n * @author Alex Dupre\n */\n\n\nvar StringUtils =\n/** @class */\nfunction () {\n  function StringUtils() {} // SHIFT_JIS.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING) ||\n  // EUC_JP.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING);\n\n\n  StringUtils.castAsNonUtf8Char = function (code, encoding) {\n    if (encoding === void 0) {\n      encoding = null;\n    } // ISO 8859-1 is the Java default as UTF-8 is JavaScripts\n    // you can see this method as a Java version of String.fromCharCode\n\n\n    var e = encoding ? encoding.getName() : this.ISO88591; // use passed format (fromCharCode will return UTF8 encoding)\n\n    return StringEncoding_1.default.decode(new Uint8Array([code]), e);\n  };\n  /**\n   * @param bytes bytes encoding a string, whose encoding should be guessed\n   * @param hints decode hints if applicable\n   * @return name of guessed encoding; at the moment will only guess one of:\n   *  {@link #SHIFT_JIS}, {@link #UTF8}, {@link #ISO88591}, or the platform\n   *  default encoding if none of these can possibly be correct\n   */\n\n\n  StringUtils.guessEncoding = function (bytes, hints) {\n    if (hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType_1.default.CHARACTER_SET)) {\n      return hints.get(DecodeHintType_1.default.CHARACTER_SET).toString();\n    } // For now, merely tries to distinguish ISO-8859-1, UTF-8 and Shift_JIS,\n    // which should be by far the most common encodings.\n\n\n    var length = bytes.length;\n    var canBeISO88591 = true;\n    var canBeShiftJIS = true;\n    var canBeUTF8 = true;\n    var utf8BytesLeft = 0; // int utf8LowChars = 0\n\n    var utf2BytesChars = 0;\n    var utf3BytesChars = 0;\n    var utf4BytesChars = 0;\n    var sjisBytesLeft = 0; // int sjisLowChars = 0\n\n    var sjisKatakanaChars = 0; // int sjisDoubleBytesChars = 0\n\n    var sjisCurKatakanaWordLength = 0;\n    var sjisCurDoubleBytesWordLength = 0;\n    var sjisMaxKatakanaWordLength = 0;\n    var sjisMaxDoubleBytesWordLength = 0; // int isoLowChars = 0\n    // int isoHighChars = 0\n\n    var isoHighOther = 0;\n    var utf8bom = bytes.length > 3 && bytes[0] ===\n    /*(byte) */\n    0xEF && bytes[1] ===\n    /*(byte) */\n    0xBB && bytes[2] ===\n    /*(byte) */\n    0xBF;\n\n    for (var i = 0; i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i++) {\n      var value = bytes[i] & 0xFF; // UTF-8 stuff\n\n      if (canBeUTF8) {\n        if (utf8BytesLeft > 0) {\n          if ((value & 0x80) === 0) {\n            canBeUTF8 = false;\n          } else {\n            utf8BytesLeft--;\n          }\n        } else if ((value & 0x80) !== 0) {\n          if ((value & 0x40) === 0) {\n            canBeUTF8 = false;\n          } else {\n            utf8BytesLeft++;\n\n            if ((value & 0x20) === 0) {\n              utf2BytesChars++;\n            } else {\n              utf8BytesLeft++;\n\n              if ((value & 0x10) === 0) {\n                utf3BytesChars++;\n              } else {\n                utf8BytesLeft++;\n\n                if ((value & 0x08) === 0) {\n                  utf4BytesChars++;\n                } else {\n                  canBeUTF8 = false;\n                }\n              }\n            }\n          }\n        } // else {\n        // utf8LowChars++\n        // }\n\n      } // ISO-8859-1 stuff\n\n\n      if (canBeISO88591) {\n        if (value > 0x7F && value < 0xA0) {\n          canBeISO88591 = false;\n        } else if (value > 0x9F) {\n          if (value < 0xC0 || value === 0xD7 || value === 0xF7) {\n            isoHighOther++;\n          } // else {\n          // isoHighChars++\n          // }\n\n        } // else {\n        // isoLowChars++\n        // }\n\n      } // Shift_JIS stuff\n\n\n      if (canBeShiftJIS) {\n        if (sjisBytesLeft > 0) {\n          if (value < 0x40 || value === 0x7F || value > 0xFC) {\n            canBeShiftJIS = false;\n          } else {\n            sjisBytesLeft--;\n          }\n        } else if (value === 0x80 || value === 0xA0 || value > 0xEF) {\n          canBeShiftJIS = false;\n        } else if (value > 0xA0 && value < 0xE0) {\n          sjisKatakanaChars++;\n          sjisCurDoubleBytesWordLength = 0;\n          sjisCurKatakanaWordLength++;\n\n          if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {\n            sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;\n          }\n        } else if (value > 0x7F) {\n          sjisBytesLeft++; // sjisDoubleBytesChars++\n\n          sjisCurKatakanaWordLength = 0;\n          sjisCurDoubleBytesWordLength++;\n\n          if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {\n            sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;\n          }\n        } else {\n          // sjisLowChars++\n          sjisCurKatakanaWordLength = 0;\n          sjisCurDoubleBytesWordLength = 0;\n        }\n      }\n    }\n\n    if (canBeUTF8 && utf8BytesLeft > 0) {\n      canBeUTF8 = false;\n    }\n\n    if (canBeShiftJIS && sjisBytesLeft > 0) {\n      canBeShiftJIS = false;\n    } // Easy -- if there is BOM or at least 1 valid not-single byte character (and no evidence it can't be UTF-8), done\n\n\n    if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {\n      return StringUtils.UTF8;\n    } // Easy -- if assuming Shift_JIS or at least 3 valid consecutive not-ascii characters (and no evidence it can't be), done\n\n\n    if (canBeShiftJIS && (StringUtils.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {\n      return StringUtils.SHIFT_JIS;\n    } // Distinguishing Shift_JIS and ISO-8859-1 can be a little tough for short words. The crude heuristic is:\n    // - If we saw\n    //   - only two consecutive katakana chars in the whole text, or\n    //   - at least 10% of bytes that could be \"upper\" not-alphanumeric Latin1,\n    // - then we conclude Shift_JIS, else ISO-8859-1\n\n\n    if (canBeISO88591 && canBeShiftJIS) {\n      return sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2 || isoHighOther * 10 >= length ? StringUtils.SHIFT_JIS : StringUtils.ISO88591;\n    } // Otherwise, try in order ISO-8859-1, Shift JIS, UTF-8 and fall back to default platform encoding\n\n\n    if (canBeISO88591) {\n      return StringUtils.ISO88591;\n    }\n\n    if (canBeShiftJIS) {\n      return StringUtils.SHIFT_JIS;\n    }\n\n    if (canBeUTF8) {\n      return StringUtils.UTF8;\n    } // Otherwise, we take a wild guess with platform encoding\n\n\n    return StringUtils.PLATFORM_DEFAULT_ENCODING;\n  };\n  /**\n   *\n   * @see https://stackoverflow.com/a/13439711/4367683\n   *\n   * @param append The new string to append.\n   * @param args Argumets values to be formated.\n   */\n\n\n  StringUtils.format = function (append) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var i = -1;\n\n    function callback(exp, p0, p1, p2, p3, p4) {\n      if (exp === '%%') return '%';\n      if (args[++i] === undefined) return undefined;\n      exp = p2 ? parseInt(p2.substr(1)) : undefined;\n      var base = p3 ? parseInt(p3.substr(1)) : undefined;\n      var val;\n\n      switch (p4) {\n        case 's':\n          val = args[i];\n          break;\n\n        case 'c':\n          val = args[i][0];\n          break;\n\n        case 'f':\n          val = parseFloat(args[i]).toFixed(exp);\n          break;\n\n        case 'p':\n          val = parseFloat(args[i]).toPrecision(exp);\n          break;\n\n        case 'e':\n          val = parseFloat(args[i]).toExponential(exp);\n          break;\n\n        case 'x':\n          val = parseInt(args[i]).toString(base ? base : 16);\n          break;\n\n        case 'd':\n          val = parseFloat(parseInt(args[i], base ? base : 10).toPrecision(exp)).toFixed(0);\n          break;\n      }\n\n      val = typeof val === 'object' ? JSON.stringify(val) : (+val).toString(base);\n      var size = parseInt(p1);\n      /* padding size */\n\n      var ch = p1 && p1[0] + '' === '0' ? '0' : ' ';\n      /* isnull? */\n\n      while (val.length < size) val = p0 !== undefined ? val + ch : ch + val;\n      /* isminus? */\n\n\n      return val;\n    }\n\n    var regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;\n    return append.replace(regex, callback);\n  };\n  /**\n   *\n   */\n\n\n  StringUtils.getBytes = function (str, encoding) {\n    return StringEncoding_1.default.encode(str, encoding);\n  };\n  /**\n   * Returns the charcode at the specified index or at index zero.\n   */\n\n\n  StringUtils.getCharCode = function (str, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    return str.charCodeAt(index);\n  };\n  /**\n   * Returns char for given charcode\n   */\n\n\n  StringUtils.getCharAt = function (charCode) {\n    return String.fromCharCode(charCode);\n  };\n\n  StringUtils.SHIFT_JIS = CharacterSetECI_1.default.SJIS.getName(); // \"SJIS\"\n\n  StringUtils.GB2312 = 'GB2312';\n  StringUtils.ISO88591 = CharacterSetECI_1.default.ISO8859_1.getName(); // \"ISO8859_1\"\n\n  StringUtils.EUC_JP = 'EUC_JP';\n  StringUtils.UTF8 = CharacterSetECI_1.default.UTF8.getName(); // \"UTF8\"\n\n  StringUtils.PLATFORM_DEFAULT_ENCODING = StringUtils.UTF8; // \"UTF8\"//Charset.defaultCharset().name()\n\n  StringUtils.ASSUME_SHIFT_JIS = false;\n  return StringUtils;\n}();\n\nexports.default = StringUtils;","map":{"version":3,"sources":["../../../src/core/common/StringUtils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright (C) 2010 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.common {*/\n/*import java.nio.charset.Charset;*/\n/*import java.util.Map;*/\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\nvar CharacterSetECI_1 = require(\"./CharacterSetECI\");\nvar StringEncoding_1 = require(\"../util/StringEncoding\");\n/**\n * Common string-related functions.\n *\n * @author Sean Owen\n * @author Alex Dupre\n */\nvar StringUtils = /** @class */ (function () {\n    function StringUtils() {\n    }\n    // SHIFT_JIS.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING) ||\n    // EUC_JP.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING);\n    StringUtils.castAsNonUtf8Char = function (code, encoding) {\n        if (encoding === void 0) { encoding = null; }\n        // ISO 8859-1 is the Java default as UTF-8 is JavaScripts\n        // you can see this method as a Java version of String.fromCharCode\n        var e = encoding ? encoding.getName() : this.ISO88591;\n        // use passed format (fromCharCode will return UTF8 encoding)\n        return StringEncoding_1.default.decode(new Uint8Array([code]), e);\n    };\n    /**\n     * @param bytes bytes encoding a string, whose encoding should be guessed\n     * @param hints decode hints if applicable\n     * @return name of guessed encoding; at the moment will only guess one of:\n     *  {@link #SHIFT_JIS}, {@link #UTF8}, {@link #ISO88591}, or the platform\n     *  default encoding if none of these can possibly be correct\n     */\n    StringUtils.guessEncoding = function (bytes, hints) {\n        if (hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType_1.default.CHARACTER_SET)) {\n            return hints.get(DecodeHintType_1.default.CHARACTER_SET).toString();\n        }\n        // For now, merely tries to distinguish ISO-8859-1, UTF-8 and Shift_JIS,\n        // which should be by far the most common encodings.\n        var length = bytes.length;\n        var canBeISO88591 = true;\n        var canBeShiftJIS = true;\n        var canBeUTF8 = true;\n        var utf8BytesLeft = 0;\n        // int utf8LowChars = 0\n        var utf2BytesChars = 0;\n        var utf3BytesChars = 0;\n        var utf4BytesChars = 0;\n        var sjisBytesLeft = 0;\n        // int sjisLowChars = 0\n        var sjisKatakanaChars = 0;\n        // int sjisDoubleBytesChars = 0\n        var sjisCurKatakanaWordLength = 0;\n        var sjisCurDoubleBytesWordLength = 0;\n        var sjisMaxKatakanaWordLength = 0;\n        var sjisMaxDoubleBytesWordLength = 0;\n        // int isoLowChars = 0\n        // int isoHighChars = 0\n        var isoHighOther = 0;\n        var utf8bom = bytes.length > 3 &&\n            bytes[0] === /*(byte) */ 0xEF &&\n            bytes[1] === /*(byte) */ 0xBB &&\n            bytes[2] === /*(byte) */ 0xBF;\n        for (var i = 0; i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i++) {\n            var value = bytes[i] & 0xFF;\n            // UTF-8 stuff\n            if (canBeUTF8) {\n                if (utf8BytesLeft > 0) {\n                    if ((value & 0x80) === 0) {\n                        canBeUTF8 = false;\n                    }\n                    else {\n                        utf8BytesLeft--;\n                    }\n                }\n                else if ((value & 0x80) !== 0) {\n                    if ((value & 0x40) === 0) {\n                        canBeUTF8 = false;\n                    }\n                    else {\n                        utf8BytesLeft++;\n                        if ((value & 0x20) === 0) {\n                            utf2BytesChars++;\n                        }\n                        else {\n                            utf8BytesLeft++;\n                            if ((value & 0x10) === 0) {\n                                utf3BytesChars++;\n                            }\n                            else {\n                                utf8BytesLeft++;\n                                if ((value & 0x08) === 0) {\n                                    utf4BytesChars++;\n                                }\n                                else {\n                                    canBeUTF8 = false;\n                                }\n                            }\n                        }\n                    }\n                } // else {\n                // utf8LowChars++\n                // }\n            }\n            // ISO-8859-1 stuff\n            if (canBeISO88591) {\n                if (value > 0x7F && value < 0xA0) {\n                    canBeISO88591 = false;\n                }\n                else if (value > 0x9F) {\n                    if (value < 0xC0 || value === 0xD7 || value === 0xF7) {\n                        isoHighOther++;\n                    } // else {\n                    // isoHighChars++\n                    // }\n                } // else {\n                // isoLowChars++\n                // }\n            }\n            // Shift_JIS stuff\n            if (canBeShiftJIS) {\n                if (sjisBytesLeft > 0) {\n                    if (value < 0x40 || value === 0x7F || value > 0xFC) {\n                        canBeShiftJIS = false;\n                    }\n                    else {\n                        sjisBytesLeft--;\n                    }\n                }\n                else if (value === 0x80 || value === 0xA0 || value > 0xEF) {\n                    canBeShiftJIS = false;\n                }\n                else if (value > 0xA0 && value < 0xE0) {\n                    sjisKatakanaChars++;\n                    sjisCurDoubleBytesWordLength = 0;\n                    sjisCurKatakanaWordLength++;\n                    if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {\n                        sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;\n                    }\n                }\n                else if (value > 0x7F) {\n                    sjisBytesLeft++;\n                    // sjisDoubleBytesChars++\n                    sjisCurKatakanaWordLength = 0;\n                    sjisCurDoubleBytesWordLength++;\n                    if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {\n                        sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;\n                    }\n                }\n                else {\n                    // sjisLowChars++\n                    sjisCurKatakanaWordLength = 0;\n                    sjisCurDoubleBytesWordLength = 0;\n                }\n            }\n        }\n        if (canBeUTF8 && utf8BytesLeft > 0) {\n            canBeUTF8 = false;\n        }\n        if (canBeShiftJIS && sjisBytesLeft > 0) {\n            canBeShiftJIS = false;\n        }\n        // Easy -- if there is BOM or at least 1 valid not-single byte character (and no evidence it can't be UTF-8), done\n        if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {\n            return StringUtils.UTF8;\n        }\n        // Easy -- if assuming Shift_JIS or at least 3 valid consecutive not-ascii characters (and no evidence it can't be), done\n        if (canBeShiftJIS && (StringUtils.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {\n            return StringUtils.SHIFT_JIS;\n        }\n        // Distinguishing Shift_JIS and ISO-8859-1 can be a little tough for short words. The crude heuristic is:\n        // - If we saw\n        //   - only two consecutive katakana chars in the whole text, or\n        //   - at least 10% of bytes that could be \"upper\" not-alphanumeric Latin1,\n        // - then we conclude Shift_JIS, else ISO-8859-1\n        if (canBeISO88591 && canBeShiftJIS) {\n            return (sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2) || isoHighOther * 10 >= length\n                ? StringUtils.SHIFT_JIS : StringUtils.ISO88591;\n        }\n        // Otherwise, try in order ISO-8859-1, Shift JIS, UTF-8 and fall back to default platform encoding\n        if (canBeISO88591) {\n            return StringUtils.ISO88591;\n        }\n        if (canBeShiftJIS) {\n            return StringUtils.SHIFT_JIS;\n        }\n        if (canBeUTF8) {\n            return StringUtils.UTF8;\n        }\n        // Otherwise, we take a wild guess with platform encoding\n        return StringUtils.PLATFORM_DEFAULT_ENCODING;\n    };\n    /**\n     *\n     * @see https://stackoverflow.com/a/13439711/4367683\n     *\n     * @param append The new string to append.\n     * @param args Argumets values to be formated.\n     */\n    StringUtils.format = function (append) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var i = -1;\n        function callback(exp, p0, p1, p2, p3, p4) {\n            if (exp === '%%')\n                return '%';\n            if (args[++i] === undefined)\n                return undefined;\n            exp = p2 ? parseInt(p2.substr(1)) : undefined;\n            var base = p3 ? parseInt(p3.substr(1)) : undefined;\n            var val;\n            switch (p4) {\n                case 's':\n                    val = args[i];\n                    break;\n                case 'c':\n                    val = args[i][0];\n                    break;\n                case 'f':\n                    val = parseFloat(args[i]).toFixed(exp);\n                    break;\n                case 'p':\n                    val = parseFloat(args[i]).toPrecision(exp);\n                    break;\n                case 'e':\n                    val = parseFloat(args[i]).toExponential(exp);\n                    break;\n                case 'x':\n                    val = parseInt(args[i]).toString(base ? base : 16);\n                    break;\n                case 'd':\n                    val = parseFloat(parseInt(args[i], base ? base : 10).toPrecision(exp)).toFixed(0);\n                    break;\n            }\n            val = typeof val === 'object' ? JSON.stringify(val) : (+val).toString(base);\n            var size = parseInt(p1); /* padding size */\n            var ch = p1 && (p1[0] + '') === '0' ? '0' : ' '; /* isnull? */\n            while (val.length < size)\n                val = p0 !== undefined ? val + ch : ch + val; /* isminus? */\n            return val;\n        }\n        var regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;\n        return append.replace(regex, callback);\n    };\n    /**\n     *\n     */\n    StringUtils.getBytes = function (str, encoding) {\n        return StringEncoding_1.default.encode(str, encoding);\n    };\n    /**\n     * Returns the charcode at the specified index or at index zero.\n     */\n    StringUtils.getCharCode = function (str, index) {\n        if (index === void 0) { index = 0; }\n        return str.charCodeAt(index);\n    };\n    /**\n     * Returns char for given charcode\n     */\n    StringUtils.getCharAt = function (charCode) {\n        return String.fromCharCode(charCode);\n    };\n    StringUtils.SHIFT_JIS = CharacterSetECI_1.default.SJIS.getName(); // \"SJIS\"\n    StringUtils.GB2312 = 'GB2312';\n    StringUtils.ISO88591 = CharacterSetECI_1.default.ISO8859_1.getName(); // \"ISO8859_1\"\n    StringUtils.EUC_JP = 'EUC_JP';\n    StringUtils.UTF8 = CharacterSetECI_1.default.UTF8.getName(); // \"UTF8\"\n    StringUtils.PLATFORM_DEFAULT_ENCODING = StringUtils.UTF8; // \"UTF8\"//Charset.defaultCharset().name()\n    StringUtils.ASSUME_SHIFT_JIS = false;\n    return StringUtils;\n}());\nexports.default = StringUtils;\n//# sourceMappingURL=StringUtils.js.map"]},"metadata":{},"sourceType":"script"}
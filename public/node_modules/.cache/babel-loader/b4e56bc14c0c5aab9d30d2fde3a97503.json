{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BitArray_1 = require(\"../common/BitArray\");\n\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\n\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\n\nvar ResultPoint_1 = require(\"../ResultPoint\");\n\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/**\n * Encapsulates functionality and implementation that is common to all families\n * of one-dimensional barcodes.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n */\n\n\nvar OneDReader =\n/** @class */\nfunction () {\n  function OneDReader() {}\n  /*\n  @Override\n  public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {\n    return decode(image, null);\n  }\n  */\n  // Note that we don't try rotation without the try harder flag, even if rotation was supported.\n  // @Override\n\n\n  OneDReader.prototype.decode = function (image, hints) {\n    try {\n      return this.doDecode(image, hints);\n    } catch (nfe) {\n      var tryHarder = hints && hints.get(DecodeHintType_1.default.TRY_HARDER) === true;\n\n      if (tryHarder && image.isRotateSupported()) {\n        var rotatedImage = image.rotateCounterClockwise();\n        var result = this.doDecode(rotatedImage, hints); // Record that we found it rotated 90 degrees CCW / 270 degrees CW\n\n        var metadata = result.getResultMetadata();\n        var orientation_1 = 270;\n\n        if (metadata !== null && metadata.get(ResultMetadataType_1.default.ORIENTATION) === true) {\n          // But if we found it reversed in doDecode(), add in that result here:\n          orientation_1 = orientation_1 + metadata.get(ResultMetadataType_1.default.ORIENTATION) % 360;\n        }\n\n        result.putMetadata(ResultMetadataType_1.default.ORIENTATION, orientation_1); // Update result points\n\n        var points = result.getResultPoints();\n\n        if (points !== null) {\n          var height = rotatedImage.getHeight();\n\n          for (var i = 0; i < points.length; i++) {\n            points[i] = new ResultPoint_1.default(height - points[i].getY() - 1, points[i].getX());\n          }\n        }\n\n        return result;\n      } else {\n        throw new NotFoundException_1.default();\n      }\n    }\n  }; // @Override\n\n\n  OneDReader.prototype.reset = function () {// do nothing\n  };\n  /**\n   * We're going to examine rows from the middle outward, searching alternately above and below the\n   * middle, and farther out each time. rowStep is the number of rows between each successive\n   * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then\n   * middle + rowStep, then middle - (2 * rowStep), etc.\n   * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily\n   * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the\n   * image if \"trying harder\".\n   *\n   * @param image The image to decode\n   * @param hints Any hints that were requested\n   * @return The contents of the decoded barcode\n   * @throws NotFoundException Any spontaneous errors which occur\n   */\n\n\n  OneDReader.prototype.doDecode = function (image, hints) {\n    var width = image.getWidth();\n    var height = image.getHeight();\n    var row = new BitArray_1.default(width);\n    var tryHarder = hints && hints.get(DecodeHintType_1.default.TRY_HARDER) === true;\n    var rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));\n    var maxLines;\n\n    if (tryHarder) {\n      maxLines = height; // Look at the whole image, not just the center\n    } else {\n      maxLines = 15; // 15 rows spaced 1/32 apart is roughly the middle half of the image\n    }\n\n    var middle = Math.trunc(height / 2);\n\n    for (var x = 0; x < maxLines; x++) {\n      // Scanning from the middle out. Determine which row we're looking at next:\n      var rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);\n      var isAbove = (x & 0x01) === 0; // i.e. is x even?\n\n      var rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);\n\n      if (rowNumber < 0 || rowNumber >= height) {\n        // Oops, if we run off the top or bottom, stop\n        break;\n      } // Estimate black point for this row and load it:\n\n\n      try {\n        row = image.getBlackRow(rowNumber, row);\n      } catch (ignored) {\n        continue;\n      }\n\n      var _loop_1 = function (attempt) {\n        if (attempt === 1) {\n          // trying again?\n          row.reverse(); // reverse the row and continue\n          // This means we will only ever draw result points *once* in the life of this method\n          // since we want to avoid drawing the wrong points after flipping the row, and,\n          // don't want to clutter with noise from every single row scan -- just the scans\n          // that start on the center line.\n\n          if (hints && hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK) === true) {\n            var newHints_1 = new Map();\n            hints.forEach(function (hint, key) {\n              return newHints_1.set(key, hint);\n            });\n            newHints_1.delete(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n            hints = newHints_1;\n          }\n        }\n\n        try {\n          // Look for a barcode\n          var result = this_1.decodeRow(rowNumber, row, hints); // We found our barcode\n\n          if (attempt === 1) {\n            // But it was upside down, so note that\n            result.putMetadata(ResultMetadataType_1.default.ORIENTATION, 180); // And remember to flip the result points horizontally.\n\n            var points = result.getResultPoints();\n\n            if (points !== null) {\n              points[0] = new ResultPoint_1.default(width - points[0].getX() - 1, points[0].getY());\n              points[1] = new ResultPoint_1.default(width - points[1].getX() - 1, points[1].getY());\n            }\n          }\n\n          return {\n            value: result\n          };\n        } catch (re) {// continue -- just couldn't decode this row\n        }\n      };\n\n      var this_1 = this; // While we have the image data in a BitArray, it's fairly cheap to reverse it in place to\n      // handle decoding upside down barcodes.\n\n      for (var attempt = 0; attempt < 2; attempt++) {\n        var state_1 = _loop_1(attempt);\n\n        if (typeof state_1 === \"object\") return state_1.value;\n      }\n    }\n\n    throw new NotFoundException_1.default();\n  };\n  /**\n   * Records the size of successive runs of white and black pixels in a row, starting at a given point.\n   * The values are recorded in the given array, and the number of runs recorded is equal to the size\n   * of the array. If the row starts on a white pixel at the given start point, then the first count\n   * recorded is the run of white pixels starting from that point; likewise it is the count of a run\n   * of black pixels if the row begin on a black pixels at that point.\n   *\n   * @param row row to count from\n   * @param start offset into row to start at\n   * @param counters array into which to record counts\n   * @throws NotFoundException if counters cannot be filled entirely from row before running out\n   *  of pixels\n   */\n\n\n  OneDReader.recordPattern = function (row, start, counters) {\n    var numCounters = counters.length;\n\n    for (var index = 0; index < numCounters; index++) counters[index] = 0;\n\n    var end = row.getSize();\n\n    if (start >= end) {\n      throw new NotFoundException_1.default();\n    }\n\n    var isWhite = !row.get(start);\n    var counterPosition = 0;\n    var i = start;\n\n    while (i < end) {\n      if (row.get(i) !== isWhite) {\n        counters[counterPosition]++;\n      } else {\n        if (++counterPosition === numCounters) {\n          break;\n        } else {\n          counters[counterPosition] = 1;\n          isWhite = !isWhite;\n        }\n      }\n\n      i++;\n    } // If we read fully the last section of pixels and filled up our counters -- or filled\n    // the last counter but ran off the side of the image, OK. Otherwise, a problem.\n\n\n    if (!(counterPosition === numCounters || counterPosition === numCounters - 1 && i === end)) {\n      throw new NotFoundException_1.default();\n    }\n  };\n\n  OneDReader.recordPatternInReverse = function (row, start, counters) {\n    // This could be more efficient I guess\n    var numTransitionsLeft = counters.length;\n    var last = row.get(start);\n\n    while (start > 0 && numTransitionsLeft >= 0) {\n      if (row.get(--start) !== last) {\n        numTransitionsLeft--;\n        last = !last;\n      }\n    }\n\n    if (numTransitionsLeft >= 0) {\n      throw new NotFoundException_1.default();\n    }\n\n    OneDReader.recordPattern(row, start + 1, counters);\n  };\n  /**\n   * Determines how closely a set of observed counts of runs of black/white values matches a given\n   * target pattern. This is reported as the ratio of the total variance from the expected pattern\n   * proportions across all pattern elements, to the length of the pattern.\n   *\n   * @param counters observed counters\n   * @param pattern expected pattern\n   * @param maxIndividualVariance The most any counter can differ before we give up\n   * @return ratio of total variance between counters and pattern compared to total pattern size\n   */\n\n\n  OneDReader.patternMatchVariance = function (counters, pattern, maxIndividualVariance) {\n    var numCounters = counters.length;\n    var total = 0;\n    var patternLength = 0;\n\n    for (var i = 0; i < numCounters; i++) {\n      total += counters[i];\n      patternLength += pattern[i];\n    }\n\n    if (total < patternLength) {\n      // If we don't even have one pixel per unit of bar width, assume this is too small\n      // to reliably match, so fail:\n      return Number.POSITIVE_INFINITY;\n    }\n\n    var unitBarWidth = total / patternLength;\n    maxIndividualVariance *= unitBarWidth;\n    var totalVariance = 0.0;\n\n    for (var x = 0; x < numCounters; x++) {\n      var counter = counters[x];\n      var scaledPattern = pattern[x] * unitBarWidth;\n      var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n\n      if (variance > maxIndividualVariance) {\n        return Number.POSITIVE_INFINITY;\n      }\n\n      totalVariance += variance;\n    }\n\n    return totalVariance / total;\n  };\n\n  return OneDReader;\n}();\n\nexports.default = OneDReader;","map":{"version":3,"sources":["../../../src/core/oned/OneDReader.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BitArray_1 = require(\"../common/BitArray\");\nvar DecodeHintType_1 = require(\"../DecodeHintType\");\nvar ResultMetadataType_1 = require(\"../ResultMetadataType\");\nvar ResultPoint_1 = require(\"../ResultPoint\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\n/**\n * Encapsulates functionality and implementation that is common to all families\n * of one-dimensional barcodes.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n * @author Sean Owen\n */\nvar OneDReader = /** @class */ (function () {\n    function OneDReader() {\n    }\n    /*\n    @Override\n    public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {\n      return decode(image, null);\n    }\n    */\n    // Note that we don't try rotation without the try harder flag, even if rotation was supported.\n    // @Override\n    OneDReader.prototype.decode = function (image, hints) {\n        try {\n            return this.doDecode(image, hints);\n        }\n        catch (nfe) {\n            var tryHarder = hints && (hints.get(DecodeHintType_1.default.TRY_HARDER) === true);\n            if (tryHarder && image.isRotateSupported()) {\n                var rotatedImage = image.rotateCounterClockwise();\n                var result = this.doDecode(rotatedImage, hints);\n                // Record that we found it rotated 90 degrees CCW / 270 degrees CW\n                var metadata = result.getResultMetadata();\n                var orientation_1 = 270;\n                if (metadata !== null && (metadata.get(ResultMetadataType_1.default.ORIENTATION) === true)) {\n                    // But if we found it reversed in doDecode(), add in that result here:\n                    orientation_1 = (orientation_1 + metadata.get(ResultMetadataType_1.default.ORIENTATION) % 360);\n                }\n                result.putMetadata(ResultMetadataType_1.default.ORIENTATION, orientation_1);\n                // Update result points\n                var points = result.getResultPoints();\n                if (points !== null) {\n                    var height = rotatedImage.getHeight();\n                    for (var i = 0; i < points.length; i++) {\n                        points[i] = new ResultPoint_1.default(height - points[i].getY() - 1, points[i].getX());\n                    }\n                }\n                return result;\n            }\n            else {\n                throw new NotFoundException_1.default();\n            }\n        }\n    };\n    // @Override\n    OneDReader.prototype.reset = function () {\n        // do nothing\n    };\n    /**\n     * We're going to examine rows from the middle outward, searching alternately above and below the\n     * middle, and farther out each time. rowStep is the number of rows between each successive\n     * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then\n     * middle + rowStep, then middle - (2 * rowStep), etc.\n     * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily\n     * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the\n     * image if \"trying harder\".\n     *\n     * @param image The image to decode\n     * @param hints Any hints that were requested\n     * @return The contents of the decoded barcode\n     * @throws NotFoundException Any spontaneous errors which occur\n     */\n    OneDReader.prototype.doDecode = function (image, hints) {\n        var width = image.getWidth();\n        var height = image.getHeight();\n        var row = new BitArray_1.default(width);\n        var tryHarder = hints && (hints.get(DecodeHintType_1.default.TRY_HARDER) === true);\n        var rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));\n        var maxLines;\n        if (tryHarder) {\n            maxLines = height; // Look at the whole image, not just the center\n        }\n        else {\n            maxLines = 15; // 15 rows spaced 1/32 apart is roughly the middle half of the image\n        }\n        var middle = Math.trunc(height / 2);\n        for (var x = 0; x < maxLines; x++) {\n            // Scanning from the middle out. Determine which row we're looking at next:\n            var rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);\n            var isAbove = (x & 0x01) === 0; // i.e. is x even?\n            var rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);\n            if (rowNumber < 0 || rowNumber >= height) {\n                // Oops, if we run off the top or bottom, stop\n                break;\n            }\n            // Estimate black point for this row and load it:\n            try {\n                row = image.getBlackRow(rowNumber, row);\n            }\n            catch (ignored) {\n                continue;\n            }\n            var _loop_1 = function (attempt) {\n                if (attempt === 1) { // trying again?\n                    row.reverse(); // reverse the row and continue\n                    // This means we will only ever draw result points *once* in the life of this method\n                    // since we want to avoid drawing the wrong points after flipping the row, and,\n                    // don't want to clutter with noise from every single row scan -- just the scans\n                    // that start on the center line.\n                    if (hints && (hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK) === true)) {\n                        var newHints_1 = new Map();\n                        hints.forEach(function (hint, key) { return newHints_1.set(key, hint); });\n                        newHints_1.delete(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);\n                        hints = newHints_1;\n                    }\n                }\n                try {\n                    // Look for a barcode\n                    var result = this_1.decodeRow(rowNumber, row, hints);\n                    // We found our barcode\n                    if (attempt === 1) {\n                        // But it was upside down, so note that\n                        result.putMetadata(ResultMetadataType_1.default.ORIENTATION, 180);\n                        // And remember to flip the result points horizontally.\n                        var points = result.getResultPoints();\n                        if (points !== null) {\n                            points[0] = new ResultPoint_1.default(width - points[0].getX() - 1, points[0].getY());\n                            points[1] = new ResultPoint_1.default(width - points[1].getX() - 1, points[1].getY());\n                        }\n                    }\n                    return { value: result };\n                }\n                catch (re) {\n                    // continue -- just couldn't decode this row\n                }\n            };\n            var this_1 = this;\n            // While we have the image data in a BitArray, it's fairly cheap to reverse it in place to\n            // handle decoding upside down barcodes.\n            for (var attempt = 0; attempt < 2; attempt++) {\n                var state_1 = _loop_1(attempt);\n                if (typeof state_1 === \"object\")\n                    return state_1.value;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    /**\n     * Records the size of successive runs of white and black pixels in a row, starting at a given point.\n     * The values are recorded in the given array, and the number of runs recorded is equal to the size\n     * of the array. If the row starts on a white pixel at the given start point, then the first count\n     * recorded is the run of white pixels starting from that point; likewise it is the count of a run\n     * of black pixels if the row begin on a black pixels at that point.\n     *\n     * @param row row to count from\n     * @param start offset into row to start at\n     * @param counters array into which to record counts\n     * @throws NotFoundException if counters cannot be filled entirely from row before running out\n     *  of pixels\n     */\n    OneDReader.recordPattern = function (row, start, counters) {\n        var numCounters = counters.length;\n        for (var index = 0; index < numCounters; index++)\n            counters[index] = 0;\n        var end = row.getSize();\n        if (start >= end) {\n            throw new NotFoundException_1.default();\n        }\n        var isWhite = !row.get(start);\n        var counterPosition = 0;\n        var i = start;\n        while (i < end) {\n            if (row.get(i) !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (++counterPosition === numCounters) {\n                    break;\n                }\n                else {\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            i++;\n        }\n        // If we read fully the last section of pixels and filled up our counters -- or filled\n        // the last counter but ran off the side of the image, OK. Otherwise, a problem.\n        if (!(counterPosition === numCounters || (counterPosition === numCounters - 1 && i === end))) {\n            throw new NotFoundException_1.default();\n        }\n    };\n    OneDReader.recordPatternInReverse = function (row, start, counters) {\n        // This could be more efficient I guess\n        var numTransitionsLeft = counters.length;\n        var last = row.get(start);\n        while (start > 0 && numTransitionsLeft >= 0) {\n            if (row.get(--start) !== last) {\n                numTransitionsLeft--;\n                last = !last;\n            }\n        }\n        if (numTransitionsLeft >= 0) {\n            throw new NotFoundException_1.default();\n        }\n        OneDReader.recordPattern(row, start + 1, counters);\n    };\n    /**\n     * Determines how closely a set of observed counts of runs of black/white values matches a given\n     * target pattern. This is reported as the ratio of the total variance from the expected pattern\n     * proportions across all pattern elements, to the length of the pattern.\n     *\n     * @param counters observed counters\n     * @param pattern expected pattern\n     * @param maxIndividualVariance The most any counter can differ before we give up\n     * @return ratio of total variance between counters and pattern compared to total pattern size\n     */\n    OneDReader.patternMatchVariance = function (counters, pattern, maxIndividualVariance) {\n        var numCounters = counters.length;\n        var total = 0;\n        var patternLength = 0;\n        for (var i = 0; i < numCounters; i++) {\n            total += counters[i];\n            patternLength += pattern[i];\n        }\n        if (total < patternLength) {\n            // If we don't even have one pixel per unit of bar width, assume this is too small\n            // to reliably match, so fail:\n            return Number.POSITIVE_INFINITY;\n        }\n        var unitBarWidth = total / patternLength;\n        maxIndividualVariance *= unitBarWidth;\n        var totalVariance = 0.0;\n        for (var x = 0; x < numCounters; x++) {\n            var counter = counters[x];\n            var scaledPattern = pattern[x] * unitBarWidth;\n            var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n            if (variance > maxIndividualVariance) {\n                return Number.POSITIVE_INFINITY;\n            }\n            totalVariance += variance;\n        }\n        return totalVariance / total;\n    };\n    return OneDReader;\n}());\nexports.default = OneDReader;\n//# sourceMappingURL=OneDReader.js.map"]},"metadata":{},"sourceType":"script"}
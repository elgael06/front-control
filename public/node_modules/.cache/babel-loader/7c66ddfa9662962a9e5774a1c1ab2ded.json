{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*namespace com.google.zxing.oned {*/\n\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\n\nvar ChecksumException_1 = require(\"../ChecksumException\");\n\nvar FormatException_1 = require(\"../FormatException\");\n\nvar NotFoundException_1 = require(\"../NotFoundException\");\n\nvar OneDReader_1 = require(\"./OneDReader\");\n\nvar Result_1 = require(\"../Result\");\n\nvar ResultPoint_1 = require(\"../ResultPoint\");\n/**\n * <p>Decodes Code 39 barcodes. Supports \"Full ASCII Code 39\" if USE_CODE_39_EXTENDED_MODE is set.</p>\n *\n * @author Sean Owen\n * @see Code93Reader\n */\n\n\nvar Code39Reader =\n/** @class */\nfunction (_super) {\n  __extends(Code39Reader, _super);\n  /**\n   * Creates a reader that assumes all encoded data is data, and does not treat the final\n   * character as a check digit. It will not decoded \"extended Code 39\" sequences.\n   */\n  // public Code39Reader() {\n  //   this(false);\n  // }\n\n  /**\n   * Creates a reader that can be configured to check the last character as a check digit.\n   * It will not decoded \"extended Code 39\" sequences.\n   *\n   * @param usingCheckDigit if true, treat the last data character as a check digit, not\n   * data, and verify that the checksum passes.\n   */\n  // public Code39Reader(boolean usingCheckDigit) {\n  //   this(usingCheckDigit, false);\n  // }\n\n  /**\n   * Creates a reader that can be configured to check the last character as a check digit,\n   * or optionally attempt to decode \"extended Code 39\" sequences that are used to encode\n   * the full ASCII character set.\n   *\n   * @param usingCheckDigit if true, treat the last data character as a check digit, not\n   * data, and verify that the checksum passes.\n   * @param extendedMode if true, will attempt to decode extended Code 39 sequences in the\n   * text.\n   */\n\n\n  function Code39Reader(usingCheckDigit, extendedMode) {\n    if (usingCheckDigit === void 0) {\n      usingCheckDigit = false;\n    }\n\n    if (extendedMode === void 0) {\n      extendedMode = false;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.usingCheckDigit = usingCheckDigit;\n    _this.extendedMode = extendedMode;\n    _this.decodeRowResult = '';\n    _this.counters = new Array(9);\n    return _this;\n  }\n\n  Code39Reader.prototype.decodeRow = function (rowNumber, row, hints) {\n    var e_1, _a, e_2, _b;\n\n    var theCounters = this.counters;\n    theCounters.fill(0);\n    this.decodeRowResult = '';\n    var start = Code39Reader.findAsteriskPattern(row, theCounters); // Read off white space\n\n    var nextStart = row.getNextSet(start[1]);\n    var end = row.getSize();\n    var decodedChar;\n    var lastStart;\n\n    do {\n      Code39Reader.recordPattern(row, nextStart, theCounters);\n      var pattern = Code39Reader.toNarrowWidePattern(theCounters);\n\n      if (pattern < 0) {\n        throw new NotFoundException_1.default();\n      }\n\n      decodedChar = Code39Reader.patternToChar(pattern);\n      this.decodeRowResult += decodedChar;\n      lastStart = nextStart;\n\n      try {\n        for (var theCounters_1 = __values(theCounters), theCounters_1_1 = theCounters_1.next(); !theCounters_1_1.done; theCounters_1_1 = theCounters_1.next()) {\n          var counter = theCounters_1_1.value;\n          nextStart += counter;\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (theCounters_1_1 && !theCounters_1_1.done && (_a = theCounters_1.return)) _a.call(theCounters_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      } // Read off white space\n\n\n      nextStart = row.getNextSet(nextStart);\n    } while (decodedChar !== '*');\n\n    this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1); // remove asterisk\n    // Look for whitespace after pattern:\n\n    var lastPatternSize = 0;\n\n    try {\n      for (var theCounters_2 = __values(theCounters), theCounters_2_1 = theCounters_2.next(); !theCounters_2_1.done; theCounters_2_1 = theCounters_2.next()) {\n        var counter = theCounters_2_1.value;\n        lastPatternSize += counter;\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (theCounters_2_1 && !theCounters_2_1.done && (_b = theCounters_2.return)) _b.call(theCounters_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    var whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize; // If 50% of last pattern size, following last pattern, is not whitespace, fail\n    // (but if it's whitespace to the very end of the image, that's OK)\n\n    if (nextStart !== end && whiteSpaceAfterEnd * 2 < lastPatternSize) {\n      throw new NotFoundException_1.default();\n    }\n\n    if (this.usingCheckDigit) {\n      var max = this.decodeRowResult.length - 1;\n      var total = 0;\n\n      for (var i = 0; i < max; i++) {\n        total += Code39Reader.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i));\n      }\n\n      if (this.decodeRowResult.charAt(max) !== Code39Reader.ALPHABET_STRING.charAt(total % 43)) {\n        throw new ChecksumException_1.default();\n      }\n\n      this.decodeRowResult = this.decodeRowResult.substring(0, max);\n    }\n\n    if (this.decodeRowResult.length === 0) {\n      // false positive\n      throw new NotFoundException_1.default();\n    }\n\n    var resultString;\n\n    if (this.extendedMode) {\n      resultString = Code39Reader.decodeExtended(this.decodeRowResult);\n    } else {\n      resultString = this.decodeRowResult;\n    }\n\n    var left = (start[1] + start[0]) / 2.0;\n    var right = lastStart + lastPatternSize / 2.0;\n    return new Result_1.default(resultString, null, 0, [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)], BarcodeFormat_1.default.CODE_39, new Date().getTime());\n  };\n\n  Code39Reader.findAsteriskPattern = function (row, counters) {\n    var width = row.getSize();\n    var rowOffset = row.getNextSet(0);\n    var counterPosition = 0;\n    var patternStart = rowOffset;\n    var isWhite = false;\n    var patternLength = counters.length;\n\n    for (var i = rowOffset; i < width; i++) {\n      if (row.get(i) !== isWhite) {\n        counters[counterPosition]++;\n      } else {\n        if (counterPosition === patternLength - 1) {\n          // Look for whitespace before start pattern, >= 50% of width of start pattern\n          if (this.toNarrowWidePattern(counters) === Code39Reader.ASTERISK_ENCODING && row.isRange(Math.max(0, patternStart - Math.floor((i - patternStart) / 2)), patternStart, false)) {\n            return [patternStart, i];\n          }\n\n          patternStart += counters[0] + counters[1];\n          counters.copyWithin(0, 2, 2 + counterPosition - 1);\n          counters[counterPosition - 1] = 0;\n          counters[counterPosition] = 0;\n          counterPosition--;\n        } else {\n          counterPosition++;\n        }\n\n        counters[counterPosition] = 1;\n        isWhite = !isWhite;\n      }\n    }\n\n    throw new NotFoundException_1.default();\n  }; // For efficiency, returns -1 on failure. Not throwing here saved as many as 700 exceptions\n  // per image when using some of our blackbox images.\n\n\n  Code39Reader.toNarrowWidePattern = function (counters) {\n    var e_3, _a;\n\n    var numCounters = counters.length;\n    var maxNarrowCounter = 0;\n    var wideCounters;\n\n    do {\n      var minCounter = 0x7fffffff;\n\n      try {\n        for (var counters_1 = __values(counters), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {\n          var counter = counters_1_1.value;\n\n          if (counter < minCounter && counter > maxNarrowCounter) {\n            minCounter = counter;\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      maxNarrowCounter = minCounter;\n      wideCounters = 0;\n      var totalWideCountersWidth = 0;\n      var pattern = 0;\n\n      for (var i = 0; i < numCounters; i++) {\n        var counter = counters[i];\n\n        if (counter > maxNarrowCounter) {\n          pattern |= 1 << numCounters - 1 - i;\n          wideCounters++;\n          totalWideCountersWidth += counter;\n        }\n      }\n\n      if (wideCounters === 3) {\n        // Found 3 wide counters, but are they close enough in width?\n        // We can perform a cheap, conservative check to see if any individual\n        // counter is more than 1.5 times the average:\n        for (var i = 0; i < numCounters && wideCounters > 0; i++) {\n          var counter = counters[i];\n\n          if (counter > maxNarrowCounter) {\n            wideCounters--; // totalWideCountersWidth = 3 * average, so this checks if counter >= 3/2 * average\n\n            if (counter * 2 >= totalWideCountersWidth) {\n              return -1;\n            }\n          }\n        }\n\n        return pattern;\n      }\n    } while (wideCounters > 3);\n\n    return -1;\n  };\n\n  Code39Reader.patternToChar = function (pattern) {\n    for (var i = 0; i < Code39Reader.CHARACTER_ENCODINGS.length; i++) {\n      if (Code39Reader.CHARACTER_ENCODINGS[i] === pattern) {\n        return Code39Reader.ALPHABET_STRING.charAt(i);\n      }\n    }\n\n    if (pattern === Code39Reader.ASTERISK_ENCODING) {\n      return '*';\n    }\n\n    throw new NotFoundException_1.default();\n  };\n\n  Code39Reader.decodeExtended = function (encoded) {\n    var length = encoded.length;\n    var decoded = '';\n\n    for (var i = 0; i < length; i++) {\n      var c = encoded.charAt(i);\n\n      if (c === '+' || c === '$' || c === '%' || c === '/') {\n        var next = encoded.charAt(i + 1);\n        var decodedChar = '\\0';\n\n        switch (c) {\n          case '+':\n            // +A to +Z map to a to z\n            if (next >= 'A' && next <= 'Z') {\n              decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);\n            } else {\n              throw new FormatException_1.default();\n            }\n\n            break;\n\n          case '$':\n            // $A to $Z map to control codes SH to SB\n            if (next >= 'A' && next <= 'Z') {\n              decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);\n            } else {\n              throw new FormatException_1.default();\n            }\n\n            break;\n\n          case '%':\n            // %A to %E map to control codes ESC to US\n            if (next >= 'A' && next <= 'E') {\n              decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);\n            } else if (next >= 'F' && next <= 'J') {\n              decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);\n            } else if (next >= 'K' && next <= 'O') {\n              decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);\n            } else if (next >= 'P' && next <= 'T') {\n              decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);\n            } else if (next === 'U') {\n              decodedChar = '\\0';\n            } else if (next === 'V') {\n              decodedChar = '@';\n            } else if (next === 'W') {\n              decodedChar = '`';\n            } else if (next === 'X' || next === 'Y' || next === 'Z') {\n              decodedChar = '\\x7f';\n            } else {\n              throw new FormatException_1.default();\n            }\n\n            break;\n\n          case '/':\n            // /A to /O map to ! to , and /Z maps to :\n            if (next >= 'A' && next <= 'O') {\n              decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);\n            } else if (next === 'Z') {\n              decodedChar = ':';\n            } else {\n              throw new FormatException_1.default();\n            }\n\n            break;\n        }\n\n        decoded += decodedChar; // bump up i again since we read two characters\n\n        i++;\n      } else {\n        decoded += c;\n      }\n    }\n\n    return decoded;\n  };\n\n  Code39Reader.ALPHABET_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%';\n  /**\n   * These represent the encodings of characters, as patterns of wide and narrow bars.\n   * The 9 least-significant bits of each int correspond to the pattern of wide and narrow,\n   * with 1s representing \"wide\" and 0s representing narrow.\n   */\n\n  Code39Reader.CHARACTER_ENCODINGS = [0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064, 0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C, 0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016, 0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x0A8, 0x0A2, 0x08A, 0x02A // /-%\n  ];\n  Code39Reader.ASTERISK_ENCODING = 0x094;\n  return Code39Reader;\n}(OneDReader_1.default);\n\nexports.default = Code39Reader;","map":{"version":3,"sources":["../../../src/core/oned/Code39Reader.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*namespace com.google.zxing.oned {*/\nvar BarcodeFormat_1 = require(\"../BarcodeFormat\");\nvar ChecksumException_1 = require(\"../ChecksumException\");\nvar FormatException_1 = require(\"../FormatException\");\nvar NotFoundException_1 = require(\"../NotFoundException\");\nvar OneDReader_1 = require(\"./OneDReader\");\nvar Result_1 = require(\"../Result\");\nvar ResultPoint_1 = require(\"../ResultPoint\");\n/**\n * <p>Decodes Code 39 barcodes. Supports \"Full ASCII Code 39\" if USE_CODE_39_EXTENDED_MODE is set.</p>\n *\n * @author Sean Owen\n * @see Code93Reader\n */\nvar Code39Reader = /** @class */ (function (_super) {\n    __extends(Code39Reader, _super);\n    /**\n     * Creates a reader that assumes all encoded data is data, and does not treat the final\n     * character as a check digit. It will not decoded \"extended Code 39\" sequences.\n     */\n    // public Code39Reader() {\n    //   this(false);\n    // }\n    /**\n     * Creates a reader that can be configured to check the last character as a check digit.\n     * It will not decoded \"extended Code 39\" sequences.\n     *\n     * @param usingCheckDigit if true, treat the last data character as a check digit, not\n     * data, and verify that the checksum passes.\n     */\n    // public Code39Reader(boolean usingCheckDigit) {\n    //   this(usingCheckDigit, false);\n    // }\n    /**\n     * Creates a reader that can be configured to check the last character as a check digit,\n     * or optionally attempt to decode \"extended Code 39\" sequences that are used to encode\n     * the full ASCII character set.\n     *\n     * @param usingCheckDigit if true, treat the last data character as a check digit, not\n     * data, and verify that the checksum passes.\n     * @param extendedMode if true, will attempt to decode extended Code 39 sequences in the\n     * text.\n     */\n    function Code39Reader(usingCheckDigit, extendedMode) {\n        if (usingCheckDigit === void 0) { usingCheckDigit = false; }\n        if (extendedMode === void 0) { extendedMode = false; }\n        var _this = _super.call(this) || this;\n        _this.usingCheckDigit = usingCheckDigit;\n        _this.extendedMode = extendedMode;\n        _this.decodeRowResult = '';\n        _this.counters = new Array(9);\n        return _this;\n    }\n    Code39Reader.prototype.decodeRow = function (rowNumber, row, hints) {\n        var e_1, _a, e_2, _b;\n        var theCounters = this.counters;\n        theCounters.fill(0);\n        this.decodeRowResult = '';\n        var start = Code39Reader.findAsteriskPattern(row, theCounters);\n        // Read off white space\n        var nextStart = row.getNextSet(start[1]);\n        var end = row.getSize();\n        var decodedChar;\n        var lastStart;\n        do {\n            Code39Reader.recordPattern(row, nextStart, theCounters);\n            var pattern = Code39Reader.toNarrowWidePattern(theCounters);\n            if (pattern < 0) {\n                throw new NotFoundException_1.default();\n            }\n            decodedChar = Code39Reader.patternToChar(pattern);\n            this.decodeRowResult += decodedChar;\n            lastStart = nextStart;\n            try {\n                for (var theCounters_1 = __values(theCounters), theCounters_1_1 = theCounters_1.next(); !theCounters_1_1.done; theCounters_1_1 = theCounters_1.next()) {\n                    var counter = theCounters_1_1.value;\n                    nextStart += counter;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (theCounters_1_1 && !theCounters_1_1.done && (_a = theCounters_1.return)) _a.call(theCounters_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            // Read off white space\n            nextStart = row.getNextSet(nextStart);\n        } while (decodedChar !== '*');\n        this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1); // remove asterisk\n        // Look for whitespace after pattern:\n        var lastPatternSize = 0;\n        try {\n            for (var theCounters_2 = __values(theCounters), theCounters_2_1 = theCounters_2.next(); !theCounters_2_1.done; theCounters_2_1 = theCounters_2.next()) {\n                var counter = theCounters_2_1.value;\n                lastPatternSize += counter;\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (theCounters_2_1 && !theCounters_2_1.done && (_b = theCounters_2.return)) _b.call(theCounters_2);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        var whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize;\n        // If 50% of last pattern size, following last pattern, is not whitespace, fail\n        // (but if it's whitespace to the very end of the image, that's OK)\n        if (nextStart !== end && (whiteSpaceAfterEnd * 2) < lastPatternSize) {\n            throw new NotFoundException_1.default();\n        }\n        if (this.usingCheckDigit) {\n            var max = this.decodeRowResult.length - 1;\n            var total = 0;\n            for (var i = 0; i < max; i++) {\n                total += Code39Reader.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i));\n            }\n            if (this.decodeRowResult.charAt(max) !== Code39Reader.ALPHABET_STRING.charAt(total % 43)) {\n                throw new ChecksumException_1.default();\n            }\n            this.decodeRowResult = this.decodeRowResult.substring(0, max);\n        }\n        if (this.decodeRowResult.length === 0) {\n            // false positive\n            throw new NotFoundException_1.default();\n        }\n        var resultString;\n        if (this.extendedMode) {\n            resultString = Code39Reader.decodeExtended(this.decodeRowResult);\n        }\n        else {\n            resultString = this.decodeRowResult;\n        }\n        var left = (start[1] + start[0]) / 2.0;\n        var right = lastStart + lastPatternSize / 2.0;\n        return new Result_1.default(resultString, null, 0, [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)], BarcodeFormat_1.default.CODE_39, new Date().getTime());\n    };\n    Code39Reader.findAsteriskPattern = function (row, counters) {\n        var width = row.getSize();\n        var rowOffset = row.getNextSet(0);\n        var counterPosition = 0;\n        var patternStart = rowOffset;\n        var isWhite = false;\n        var patternLength = counters.length;\n        for (var i = rowOffset; i < width; i++) {\n            if (row.get(i) !== isWhite) {\n                counters[counterPosition]++;\n            }\n            else {\n                if (counterPosition === patternLength - 1) {\n                    // Look for whitespace before start pattern, >= 50% of width of start pattern\n                    if (this.toNarrowWidePattern(counters) === Code39Reader.ASTERISK_ENCODING &&\n                        row.isRange(Math.max(0, patternStart - Math.floor((i - patternStart) / 2)), patternStart, false)) {\n                        return [patternStart, i];\n                    }\n                    patternStart += counters[0] + counters[1];\n                    counters.copyWithin(0, 2, 2 + counterPosition - 1);\n                    counters[counterPosition - 1] = 0;\n                    counters[counterPosition] = 0;\n                    counterPosition--;\n                }\n                else {\n                    counterPosition++;\n                }\n                counters[counterPosition] = 1;\n                isWhite = !isWhite;\n            }\n        }\n        throw new NotFoundException_1.default();\n    };\n    // For efficiency, returns -1 on failure. Not throwing here saved as many as 700 exceptions\n    // per image when using some of our blackbox images.\n    Code39Reader.toNarrowWidePattern = function (counters) {\n        var e_3, _a;\n        var numCounters = counters.length;\n        var maxNarrowCounter = 0;\n        var wideCounters;\n        do {\n            var minCounter = 0x7fffffff;\n            try {\n                for (var counters_1 = __values(counters), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {\n                    var counter = counters_1_1.value;\n                    if (counter < minCounter && counter > maxNarrowCounter) {\n                        minCounter = counter;\n                    }\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n            maxNarrowCounter = minCounter;\n            wideCounters = 0;\n            var totalWideCountersWidth = 0;\n            var pattern = 0;\n            for (var i = 0; i < numCounters; i++) {\n                var counter = counters[i];\n                if (counter > maxNarrowCounter) {\n                    pattern |= 1 << (numCounters - 1 - i);\n                    wideCounters++;\n                    totalWideCountersWidth += counter;\n                }\n            }\n            if (wideCounters === 3) {\n                // Found 3 wide counters, but are they close enough in width?\n                // We can perform a cheap, conservative check to see if any individual\n                // counter is more than 1.5 times the average:\n                for (var i = 0; i < numCounters && wideCounters > 0; i++) {\n                    var counter = counters[i];\n                    if (counter > maxNarrowCounter) {\n                        wideCounters--;\n                        // totalWideCountersWidth = 3 * average, so this checks if counter >= 3/2 * average\n                        if ((counter * 2) >= totalWideCountersWidth) {\n                            return -1;\n                        }\n                    }\n                }\n                return pattern;\n            }\n        } while (wideCounters > 3);\n        return -1;\n    };\n    Code39Reader.patternToChar = function (pattern) {\n        for (var i = 0; i < Code39Reader.CHARACTER_ENCODINGS.length; i++) {\n            if (Code39Reader.CHARACTER_ENCODINGS[i] === pattern) {\n                return Code39Reader.ALPHABET_STRING.charAt(i);\n            }\n        }\n        if (pattern === Code39Reader.ASTERISK_ENCODING) {\n            return '*';\n        }\n        throw new NotFoundException_1.default();\n    };\n    Code39Reader.decodeExtended = function (encoded) {\n        var length = encoded.length;\n        var decoded = '';\n        for (var i = 0; i < length; i++) {\n            var c = encoded.charAt(i);\n            if (c === '+' || c === '$' || c === '%' || c === '/') {\n                var next = encoded.charAt(i + 1);\n                var decodedChar = '\\0';\n                switch (c) {\n                    case '+':\n                        // +A to +Z map to a to z\n                        if (next >= 'A' && next <= 'Z') {\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    case '$':\n                        // $A to $Z map to control codes SH to SB\n                        if (next >= 'A' && next <= 'Z') {\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    case '%':\n                        // %A to %E map to control codes ESC to US\n                        if (next >= 'A' && next <= 'E') {\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);\n                        }\n                        else if (next >= 'F' && next <= 'J') {\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);\n                        }\n                        else if (next >= 'K' && next <= 'O') {\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);\n                        }\n                        else if (next >= 'P' && next <= 'T') {\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);\n                        }\n                        else if (next === 'U') {\n                            decodedChar = '\\0';\n                        }\n                        else if (next === 'V') {\n                            decodedChar = '@';\n                        }\n                        else if (next === 'W') {\n                            decodedChar = '`';\n                        }\n                        else if (next === 'X' || next === 'Y' || next === 'Z') {\n                            decodedChar = '\\x7f';\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                    case '/':\n                        // /A to /O map to ! to , and /Z maps to :\n                        if (next >= 'A' && next <= 'O') {\n                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);\n                        }\n                        else if (next === 'Z') {\n                            decodedChar = ':';\n                        }\n                        else {\n                            throw new FormatException_1.default();\n                        }\n                        break;\n                }\n                decoded += decodedChar;\n                // bump up i again since we read two characters\n                i++;\n            }\n            else {\n                decoded += c;\n            }\n        }\n        return decoded;\n    };\n    Code39Reader.ALPHABET_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%';\n    /**\n     * These represent the encodings of characters, as patterns of wide and narrow bars.\n     * The 9 least-significant bits of each int correspond to the pattern of wide and narrow,\n     * with 1s representing \"wide\" and 0s representing narrow.\n     */\n    Code39Reader.CHARACTER_ENCODINGS = [\n        0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064,\n        0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C,\n        0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016,\n        0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x0A8,\n        0x0A2, 0x08A, 0x02A // /-%\n    ];\n    Code39Reader.ASTERISK_ENCODING = 0x094;\n    return Code39Reader;\n}(OneDReader_1.default));\nexports.default = Code39Reader;\n//# sourceMappingURL=Code39Reader.js.map"]},"metadata":{},"sourceType":"script"}